{"version":3,"sources":["../node_modules/graphql/version.mjs","../node_modules/graphql/jsutils/isPromise.mjs","../node_modules/graphql/jsutils/Path.mjs","../node_modules/graphql/utilities/getOperationRootType.mjs","../node_modules/graphql/jsutils/printPathArray.mjs","../node_modules/graphql/utilities/coerceInputValue.mjs","../node_modules/graphql/execution/values.mjs","../node_modules/graphql/execution/execute.mjs","../node_modules/graphql/jsutils/promiseReduce.mjs","../node_modules/graphql/jsutils/promiseForObject.mjs","../node_modules/graphql/jsutils/memoize3.mjs","../node_modules/graphql/graphql.mjs","../node_modules/graphql/jsutils/isAsyncIterable.mjs","../node_modules/graphql/subscription/mapAsyncIterator.mjs","../node_modules/graphql/subscription/subscribe.mjs","../node_modules/graphql/validation/rules/custom/NoSchemaIntrospectionCustomRule.mjs","../node_modules/graphql/error/formatError.mjs","../node_modules/graphql/utilities/getOperationAST.mjs","../node_modules/graphql/utilities/introspectionFromSchema.mjs","../node_modules/graphql/utilities/extendSchema.mjs","../node_modules/graphql/utilities/buildASTSchema.mjs","../node_modules/graphql/utilities/lexicographicSortSchema.mjs","../node_modules/graphql/utilities/printSchema.mjs","../node_modules/graphql/utilities/concatAST.mjs","../node_modules/graphql/utilities/separateOperations.mjs","../node_modules/graphql/utilities/stripIgnoredCharacters.mjs","../node_modules/graphql/utilities/findBreakingChanges.mjs","../node_modules/graphql/utilities/findDeprecatedUsages.mjs"],"names":["version","versionInfo","Object","freeze","major","minor","patch","preReleaseTag","isPromise","value","then","addPath","prev","key","typename","pathToArray","path","flattened","curr","push","reverse","getOperationRootType","schema","operation","queryType","getQueryType","GraphQLError","mutationType","getMutationType","subscriptionType","getSubscriptionType","printPathArray","map","toString","join","coerceInputValue","inputValue","type","onError","arguments","length","undefined","defaultOnError","coerceInputValueImpl","invalidValue","error","errorPrefix","inspect","concat","message","isNonNullType","ofType","isListType","itemType","coercedList","safeArrayFrom","itemValue","index","itemPath","isInputObjectType","isObjectLike","name","coercedValue","fieldDefs","getFields","_i2","_objectValues2","objectValues","field","fieldValue","defaultValue","typeStr","_i4","_Object$keys2","keys","fieldName","suggestions","suggestionList","didYouMean","isLeafType","parseResult","parseValue","invariant","getVariableValues","varDefNodes","inputs","options","errors","maxErrors","coerced","coercedValues","_loop","varDefNode","varName","variable","varType","typeFromAST","isInputType","varTypeStr","print","hasOwnProperty","valueFromAST","_varTypeStr","_varTypeStr2","prefix","originalError","coerceVariableValues","getArgumentValues","def","node","variableValues","_node$arguments","argumentNodes","argNodeMap","keyMap","arg","_def$args2","args","argDef","argType","argumentNode","valueNode","isNull","kind","Kind","NULL","VARIABLE","variableName","getDirectiveValues","directiveDef","directiveNode","directives","find","directive","obj","prop","prototype","call","execute","argsOrSchema","document","rootValue","contextValue","operationName","fieldResolver","typeResolver","executeImpl","executeSync","result","Error","assertValidExecutionArguments","exeContext","buildExecutionContext","Array","isArray","data","fields","collectFields","selectionSet","create","parentType","sourceValue","values","callback","results","responseName","fieldNodes","fieldPath","resolveField","resolvedResult","initialValue","reduce","previous","resolved","executeFieldsSerially","executeFields","Promise","resolve","executeOperation","buildResponse","rawVariableValues","devAssert","assertValidSchema","_definition$name","_operation$variableDe","fragments","_document$definitions2","definitions","definition","OPERATION_DEFINITION","FRAGMENT_DEFINITION","coercedVariableValues","variableDefinitions","defaultFieldResolver","defaultTypeResolver","containsPromise","object","valuesAndPromises","all","resolvedObject","i","promiseForObject","runtimeType","visitedFragmentNames","_i6","_selectionSet$selecti2","selections","selection","FIELD","shouldIncludeNode","alias","INLINE_FRAGMENT","doesFragmentConditionMatch","FRAGMENT_SPREAD","fragName","fragment","skip","GraphQLSkipDirective","if","include","GraphQLIncludeDirective","typeConditionNode","typeCondition","conditionalType","isAbstractType","isSubType","source","_fieldDef$resolve","fieldDef","getFieldDef","returnType","resolveFn","info","buildResolveInfo","completed","completeValue","rawError","handleFieldError","locatedError","completedResults","item","completedItem","completeListValue","serializedResult","serialize","completeLeafValue","_returnType$resolveTy","resolveTypeFn","resolveType","resolvedRuntimeType","completeObjectValue","ensureValidRuntimeType","completeAbstractValue","isObjectType","runtimeTypeOrName","runtimeTypeName","isNamedType","getType","isTypeOf","resolvedIsTypeOf","invalidReturnTypeError","collectAndExecuteSubfields","collectSubfields","fn","cache0","a1","a2","a3","WeakMap","cache2","cache1","get","cachedValue","set","newValue","memoize3","subFieldNodes","_i8","abstractType","__typename","possibleTypes","getPossibleTypes","promisedIsTypeOfResults","isTypeOfResult","isTypeOfResults","_i9","property","SchemaMetaFieldDef","TypeMetaFieldDef","TypeNameMetaFieldDef","graphql","_arguments","graphqlImpl","graphqlSync","schemaValidationErrors","validateSchema","parse","syntaxError","validationErrors","validate","isAsyncIterable","maybeAsyncIterable","SYMBOL_ASYNC_ITERATOR","mapAsyncIterator","iterable","rejectCallback","$return","abruptClose","mapReject","iterator","mapResult","done","asyncMapValue","iteratorResult","return","rethrow","reject","next","throw","catch","this","defineProperty","enumerable","configurable","writable","subscribe","subscribeFieldResolver","subscribeImpl","reportGraphQLError","sourcePromise","createSourceEventStream","mapSourceToResponse","payload","resultOrStream","resolveResult","_fieldDef$subscribe","eventStream","executeSubscription","NoSchemaIntrospectionCustomRule","context","Field","getNamedType","isIntrospectionType","reportError","formatError","_error$message","locations","extensions","getOperationAST","documentAST","_documentAST$definiti2","ownKeys","enumerableOnly","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","apply","_defineProperty","introspectionFromSchema","optionsWithDefaults","target","forEach","getOwnPropertyDescriptors","defineProperties","_objectSpread","specifiedByUrl","directiveIsRepeatable","schemaDescription","inputValueDeprecation","getIntrospectionQuery","extendSchema","assertSchema","DOCUMENT","assumeValid","assumeValidSDL","assertValidSDLExtension","schemaConfig","toConfig","extendedConfig","extendSchemaImpl","GraphQLSchema","_schemaDef","_schemaDef$descriptio","_schemaDef2","_options$assumeValid","schemaDef","typeDefs","typeExtensionsMap","directiveDefs","schemaExtensions","SCHEMA_DEFINITION","SCHEMA_EXTENSION","isTypeDefinitionNode","isTypeExtensionNode","extendedTypeName","existingTypeExtensions","DIRECTIVE_DEFINITION","typeMap","_schemaConfig$types2","types","existingType","extendNamedType","_stdTypeMap$name","typeNode","stdTypeMap","buildType","operationTypes","query","replaceNamedType","mutation","subscription","getOperationTypes","description","config","GraphQLDirective","mapValue","extendArg","_ref","getDescription","isRepeatable","repeatable","buildArgumentMap","astNode","extensionASTNodes","replaceType","GraphQLList","GraphQLNonNull","isSpecifiedScalarType","isScalarType","_typeExtensionsMap$co2","_getSpecifiedByUrl","getSpecifiedByUrl","GraphQLScalarType","extendScalarType","_typeExtensionsMap$co3","GraphQLObjectType","interfaces","getInterfaces","buildInterfaces","extendField","buildFieldMap","extendObjectType","isInterfaceType","_typeExtensionsMap$co4","GraphQLInterfaceType","extendInterfaceType","isUnionType","_typeExtensionsMap$co5","GraphQLUnionType","getTypes","buildUnionTypes","extendUnionType","isEnumType","_typeExtensionsMap$ty","GraphQLEnumType","buildEnumValueMap","extendEnumType","_typeExtensionsMap$co","GraphQLInputObjectType","buildInputFieldMap","extendInputObjectType","nodes","opTypes","_i10","_node$operationTypes","operationTypesNodes","_i12","operationType","_stdTypeMap$name2","getWrappedType","LIST_TYPE","NON_NULL_TYPE","fieldConfigMap","_i14","_node$fields","nodeFields","_i16","deprecationReason","getDeprecationReason","argsNodes","argConfigMap","_i18","inputFieldMap","_i20","_node$fields2","fieldsNodes","_i22","enumValueMap","_i24","_node$values","valuesNodes","_i26","_i28","_node$interfaces","interfacesNodes","_i30","_i32","_node$types","typeNodes","_i34","_typeExtensionsMap$na","extensionNodes","OBJECT_TYPE_DEFINITION","allNodes","INTERFACE_TYPE_DEFINITION","_extensionASTNodes","_allNodes","ENUM_TYPE_DEFINITION","_extensionASTNodes2","_allNodes2","UNION_TYPE_DEFINITION","_extensionASTNodes3","_allNodes3","SCALAR_TYPE_DEFINITION","_extensionASTNodes4","INPUT_OBJECT_TYPE_DEFINITION","_extensionASTNodes5","_allNodes4","specifiedScalarTypes","introspectionTypes","deprecated","GraphQLDeprecatedDirective","reason","specifiedBy","GraphQLSpecifiedByDirective","url","commentDescriptions","rawValue","loc","comments","token","startToken","TokenKind","COMMENT","line","String","getLeadingCommentBlock","dedentBlockStringValue","buildASTSchema","assertValidSDL","_config$types2","stdDirective","specifiedDirectives","every","buildSchema","noLocation","allowLegacySDLEmptyFields","allowLegacySDLImplementsInterfaces","experimentalFragmentVariables","lexicographicSortSchema","keyValMap","sortByName","sortTypes","sortFields","_config","_config2","_config3","sortObjMap","_config4","sortBy","x","sortArgs","replaceMaybeType","maybeType","fieldsMap","arr","sortValueFn","sortedMap","sortedKeys","array","mapToKey","slice","sort","obj1","obj2","key1","key2","naturalCompare","printSchema","printFilteredSchema","n","isSpecifiedDirective","isDefinedType","printIntrospectionSchema","directiveFilter","typeFilter","getDirectives","getTypeMap","printSchemaDefinition","printDescription","printArgs","printDirective","printType","Boolean","isSchemaOfCommonNames","scalar","urlAST","astFromValue","GraphQLString","printSpecifiedByUrl","printScalar","printImplementedInterfaces","printFields","printObject","printInterface","printUnion","getValues","printDeprecated","printBlock","printEnum","f","printInputValue","printInputObject","items","indentation","defaultAST","argDecl","reasonAST","DEFAULT_DEPRECATION_REASON","firstInBlock","printDescriptionWithComments","preferMultipleLines","blockString","printBlockString","replace","split","concatAST","documents","doc","separateOperations","operations","depGraph","definitionNode","collectDependencies","separatedDocumentASTs","dependencies","Set","_collectDependencies2","fragmentName","collectTransitiveDependencies","has","collected","fromName","add","immediateDeps","visit","FragmentSpread","stripIgnoredCharacters","sourceObj","isSource","Source","body","lexer","Lexer","strippedBody","wasLastAddedTokenNonPunctuator","advance","EOF","currentToken","tokenKind","isNonPunctuator","isPunctuatorTokenKind","SPREAD","tokenBody","start","end","BLOCK_STRING","dedentBlockString","blockStr","rawStr","getBlockStringIndentation","lastChar","BreakingChangeType","TYPE_REMOVED","TYPE_CHANGED_KIND","TYPE_REMOVED_FROM_UNION","VALUE_REMOVED_FROM_ENUM","REQUIRED_INPUT_FIELD_ADDED","IMPLEMENTED_INTERFACE_REMOVED","FIELD_REMOVED","FIELD_CHANGED_KIND","REQUIRED_ARG_ADDED","ARG_REMOVED","ARG_CHANGED_KIND","DIRECTIVE_REMOVED","DIRECTIVE_ARG_REMOVED","REQUIRED_DIRECTIVE_ARG_ADDED","DIRECTIVE_REPEATABLE_REMOVED","DIRECTIVE_LOCATION_REMOVED","DangerousChangeType","VALUE_ADDED_TO_ENUM","TYPE_ADDED_TO_UNION","OPTIONAL_INPUT_FIELD_ADDED","OPTIONAL_ARG_ADDED","IMPLEMENTED_INTERFACE_ADDED","ARG_DEFAULT_VALUE_CHANGE","findBreakingChanges","oldSchema","newSchema","findSchemaChanges","change","findDangerousChanges","schemaChanges","typesDiff","diff","_typesDiff$removed2","removed","oldType","_typesDiff$persisted2","persisted","_ref4","_oldType","newType","findEnumTypeChanges","findUnionTypeChanges","findInputObjectTypeChanges","findFieldChanges","findImplementedInterfacesChanges","constructor","typeKindName","findTypeChanges","directivesDiff","_directivesDiff$remov2","oldDirective","_directivesDiff$persi2","_ref2","_oldDirective","newDirective","argsDiff","_argsDiff$added2","added","newArg","isRequiredArgument","_argsDiff$removed2","oldArg","_oldDirective$locatio2","location","indexOf","findDirectiveChanges","fieldsDiff","_fieldsDiff$added2","newField","isRequiredInputField","_fieldsDiff$removed2","oldField","_fieldsDiff$persisted2","_ref6","_oldField","_newField","isChangeSafeForInputObjectFieldOrFieldArg","possibleTypesDiff","_possibleTypesDiff$ad2","newPossibleType","_possibleTypesDiff$re2","oldPossibleType","valuesDiff","_valuesDiff$added2","_valuesDiff$removed2","oldValue","interfacesDiff","_interfacesDiff$added2","newInterface","_interfacesDiff$remov2","oldInterface","_fieldsDiff$removed4","_i36","_fieldsDiff$persisted4","_ref8","_oldField2","findArgChanges","isChangeSafeForObjectOrInterfaceField","_i38","_argsDiff$removed4","_i40","_argsDiff$persisted2","_ref10","_oldArg","oldValueStr","stringifyValue","newValueStr","_i42","_argsDiff$added4","_newArg","ast","sortedAST","ObjectValue","objectNode","fieldA","fieldB","oldArray","newArray","oldMap","_ref11","newMap","_ref12","_i44","oldItem","newItem","_i46","_newItem","findDeprecatedUsages","NoDeprecatedCustomRule"],"mappings":"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","file":"static/js/1.56665a80.chunk.js","sourcesContent":["/**\n * Note: This file is autogenerated using \"resources/gen-version.js\" script and\n * automatically updated by \"npm version\" command.\n */\n\n/**\n * A string containing the version of the GraphQL.js library\n */\nexport var version = '15.8.0';\n/**\n * An object containing the components of the GraphQL.js version string\n */\n\nexport var versionInfo = Object.freeze({\n  major: 15,\n  minor: 8,\n  patch: 0,\n  preReleaseTag: null\n});\n","/**\n * Returns true if the value acts like a Promise, i.e. has a \"then\" function,\n * otherwise returns false.\n */\n// eslint-disable-next-line no-redeclare\nexport default function isPromise(value) {\n  return typeof (value === null || value === void 0 ? void 0 : value.then) === 'function';\n}\n","/**\n * Given a Path and a key, return a new Path containing the new key.\n */\nexport function addPath(prev, key, typename) {\n  return {\n    prev: prev,\n    key: key,\n    typename: typename\n  };\n}\n/**\n * Given a Path, return an Array of the path keys.\n */\n\nexport function pathToArray(path) {\n  var flattened = [];\n  var curr = path;\n\n  while (curr) {\n    flattened.push(curr.key);\n    curr = curr.prev;\n  }\n\n  return flattened.reverse();\n}\n","import { GraphQLError } from \"../error/GraphQLError.mjs\";\n\n/**\n * Extracts the root type of the operation from the schema.\n */\nexport function getOperationRootType(schema, operation) {\n  if (operation.operation === 'query') {\n    var queryType = schema.getQueryType();\n\n    if (!queryType) {\n      throw new GraphQLError('Schema does not define the required query root type.', operation);\n    }\n\n    return queryType;\n  }\n\n  if (operation.operation === 'mutation') {\n    var mutationType = schema.getMutationType();\n\n    if (!mutationType) {\n      throw new GraphQLError('Schema is not configured for mutations.', operation);\n    }\n\n    return mutationType;\n  }\n\n  if (operation.operation === 'subscription') {\n    var subscriptionType = schema.getSubscriptionType();\n\n    if (!subscriptionType) {\n      throw new GraphQLError('Schema is not configured for subscriptions.', operation);\n    }\n\n    return subscriptionType;\n  }\n\n  throw new GraphQLError('Can only have query, mutation and subscription operations.', operation);\n}\n","/**\n * Build a string describing the path.\n */\nexport default function printPathArray(path) {\n  return path.map(function (key) {\n    return typeof key === 'number' ? '[' + key.toString() + ']' : '.' + key;\n  }).join('');\n}\n","import objectValues from \"../polyfills/objectValues.mjs\";\nimport inspect from \"../jsutils/inspect.mjs\";\nimport invariant from \"../jsutils/invariant.mjs\";\nimport didYouMean from \"../jsutils/didYouMean.mjs\";\nimport isObjectLike from \"../jsutils/isObjectLike.mjs\";\nimport safeArrayFrom from \"../jsutils/safeArrayFrom.mjs\";\nimport suggestionList from \"../jsutils/suggestionList.mjs\";\nimport printPathArray from \"../jsutils/printPathArray.mjs\";\nimport { addPath, pathToArray } from \"../jsutils/Path.mjs\";\nimport { GraphQLError } from \"../error/GraphQLError.mjs\";\nimport { isLeafType, isInputObjectType, isListType, isNonNullType } from \"../type/definition.mjs\";\n\n/**\n * Coerces a JavaScript value given a GraphQL Input Type.\n */\nexport function coerceInputValue(inputValue, type) {\n  var onError = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultOnError;\n  return coerceInputValueImpl(inputValue, type, onError);\n}\n\nfunction defaultOnError(path, invalidValue, error) {\n  var errorPrefix = 'Invalid value ' + inspect(invalidValue);\n\n  if (path.length > 0) {\n    errorPrefix += \" at \\\"value\".concat(printPathArray(path), \"\\\"\");\n  }\n\n  error.message = errorPrefix + ': ' + error.message;\n  throw error;\n}\n\nfunction coerceInputValueImpl(inputValue, type, onError, path) {\n  if (isNonNullType(type)) {\n    if (inputValue != null) {\n      return coerceInputValueImpl(inputValue, type.ofType, onError, path);\n    }\n\n    onError(pathToArray(path), inputValue, new GraphQLError(\"Expected non-nullable type \\\"\".concat(inspect(type), \"\\\" not to be null.\")));\n    return;\n  }\n\n  if (inputValue == null) {\n    // Explicitly return the value null.\n    return null;\n  }\n\n  if (isListType(type)) {\n    var itemType = type.ofType;\n    var coercedList = safeArrayFrom(inputValue, function (itemValue, index) {\n      var itemPath = addPath(path, index, undefined);\n      return coerceInputValueImpl(itemValue, itemType, onError, itemPath);\n    });\n\n    if (coercedList != null) {\n      return coercedList;\n    } // Lists accept a non-list value as a list of one.\n\n\n    return [coerceInputValueImpl(inputValue, itemType, onError, path)];\n  }\n\n  if (isInputObjectType(type)) {\n    if (!isObjectLike(inputValue)) {\n      onError(pathToArray(path), inputValue, new GraphQLError(\"Expected type \\\"\".concat(type.name, \"\\\" to be an object.\")));\n      return;\n    }\n\n    var coercedValue = {};\n    var fieldDefs = type.getFields();\n\n    for (var _i2 = 0, _objectValues2 = objectValues(fieldDefs); _i2 < _objectValues2.length; _i2++) {\n      var field = _objectValues2[_i2];\n      var fieldValue = inputValue[field.name];\n\n      if (fieldValue === undefined) {\n        if (field.defaultValue !== undefined) {\n          coercedValue[field.name] = field.defaultValue;\n        } else if (isNonNullType(field.type)) {\n          var typeStr = inspect(field.type);\n          onError(pathToArray(path), inputValue, new GraphQLError(\"Field \\\"\".concat(field.name, \"\\\" of required type \\\"\").concat(typeStr, \"\\\" was not provided.\")));\n        }\n\n        continue;\n      }\n\n      coercedValue[field.name] = coerceInputValueImpl(fieldValue, field.type, onError, addPath(path, field.name, type.name));\n    } // Ensure every provided field is defined.\n\n\n    for (var _i4 = 0, _Object$keys2 = Object.keys(inputValue); _i4 < _Object$keys2.length; _i4++) {\n      var fieldName = _Object$keys2[_i4];\n\n      if (!fieldDefs[fieldName]) {\n        var suggestions = suggestionList(fieldName, Object.keys(type.getFields()));\n        onError(pathToArray(path), inputValue, new GraphQLError(\"Field \\\"\".concat(fieldName, \"\\\" is not defined by type \\\"\").concat(type.name, \"\\\".\") + didYouMean(suggestions)));\n      }\n    }\n\n    return coercedValue;\n  } // istanbul ignore else (See: 'https://github.com/graphql/graphql-js/issues/2618')\n\n\n  if (isLeafType(type)) {\n    var parseResult; // Scalars and Enums determine if a input value is valid via parseValue(),\n    // which can throw to indicate failure. If it throws, maintain a reference\n    // to the original error.\n\n    try {\n      parseResult = type.parseValue(inputValue);\n    } catch (error) {\n      if (error instanceof GraphQLError) {\n        onError(pathToArray(path), inputValue, error);\n      } else {\n        onError(pathToArray(path), inputValue, new GraphQLError(\"Expected type \\\"\".concat(type.name, \"\\\". \") + error.message, undefined, undefined, undefined, undefined, error));\n      }\n\n      return;\n    }\n\n    if (parseResult === undefined) {\n      onError(pathToArray(path), inputValue, new GraphQLError(\"Expected type \\\"\".concat(type.name, \"\\\".\")));\n    }\n\n    return parseResult;\n  } // istanbul ignore next (Not reachable. All possible input types have been considered)\n\n\n  false || invariant(0, 'Unexpected input type: ' + inspect(type));\n}\n","import find from \"../polyfills/find.mjs\";\nimport keyMap from \"../jsutils/keyMap.mjs\";\nimport inspect from \"../jsutils/inspect.mjs\";\nimport printPathArray from \"../jsutils/printPathArray.mjs\";\nimport { GraphQLError } from \"../error/GraphQLError.mjs\";\nimport { Kind } from \"../language/kinds.mjs\";\nimport { print } from \"../language/printer.mjs\";\nimport { isInputType, isNonNullType } from \"../type/definition.mjs\";\nimport { typeFromAST } from \"../utilities/typeFromAST.mjs\";\nimport { valueFromAST } from \"../utilities/valueFromAST.mjs\";\nimport { coerceInputValue } from \"../utilities/coerceInputValue.mjs\";\n\n/**\n * Prepares an object map of variableValues of the correct type based on the\n * provided variable definitions and arbitrary input. If the input cannot be\n * parsed to match the variable definitions, a GraphQLError will be thrown.\n *\n * Note: The returned value is a plain Object with a prototype, since it is\n * exposed to user code. Care should be taken to not pull values from the\n * Object prototype.\n *\n * @internal\n */\nexport function getVariableValues(schema, varDefNodes, inputs, options) {\n  var errors = [];\n  var maxErrors = options === null || options === void 0 ? void 0 : options.maxErrors;\n\n  try {\n    var coerced = coerceVariableValues(schema, varDefNodes, inputs, function (error) {\n      if (maxErrors != null && errors.length >= maxErrors) {\n        throw new GraphQLError('Too many errors processing variables, error limit reached. Execution aborted.');\n      }\n\n      errors.push(error);\n    });\n\n    if (errors.length === 0) {\n      return {\n        coerced: coerced\n      };\n    }\n  } catch (error) {\n    errors.push(error);\n  }\n\n  return {\n    errors: errors\n  };\n}\n\nfunction coerceVariableValues(schema, varDefNodes, inputs, onError) {\n  var coercedValues = {};\n\n  var _loop = function _loop(_i2) {\n    var varDefNode = varDefNodes[_i2];\n    var varName = varDefNode.variable.name.value;\n    var varType = typeFromAST(schema, varDefNode.type);\n\n    if (!isInputType(varType)) {\n      // Must use input types for variables. This should be caught during\n      // validation, however is checked again here for safety.\n      var varTypeStr = print(varDefNode.type);\n      onError(new GraphQLError(\"Variable \\\"$\".concat(varName, \"\\\" expected value of type \\\"\").concat(varTypeStr, \"\\\" which cannot be used as an input type.\"), varDefNode.type));\n      return \"continue\";\n    }\n\n    if (!hasOwnProperty(inputs, varName)) {\n      if (varDefNode.defaultValue) {\n        coercedValues[varName] = valueFromAST(varDefNode.defaultValue, varType);\n      } else if (isNonNullType(varType)) {\n        var _varTypeStr = inspect(varType);\n\n        onError(new GraphQLError(\"Variable \\\"$\".concat(varName, \"\\\" of required type \\\"\").concat(_varTypeStr, \"\\\" was not provided.\"), varDefNode));\n      }\n\n      return \"continue\";\n    }\n\n    var value = inputs[varName];\n\n    if (value === null && isNonNullType(varType)) {\n      var _varTypeStr2 = inspect(varType);\n\n      onError(new GraphQLError(\"Variable \\\"$\".concat(varName, \"\\\" of non-null type \\\"\").concat(_varTypeStr2, \"\\\" must not be null.\"), varDefNode));\n      return \"continue\";\n    }\n\n    coercedValues[varName] = coerceInputValue(value, varType, function (path, invalidValue, error) {\n      var prefix = \"Variable \\\"$\".concat(varName, \"\\\" got invalid value \") + inspect(invalidValue);\n\n      if (path.length > 0) {\n        prefix += \" at \\\"\".concat(varName).concat(printPathArray(path), \"\\\"\");\n      }\n\n      onError(new GraphQLError(prefix + '; ' + error.message, varDefNode, undefined, undefined, undefined, error.originalError));\n    });\n  };\n\n  for (var _i2 = 0; _i2 < varDefNodes.length; _i2++) {\n    var _ret = _loop(_i2);\n\n    if (_ret === \"continue\") continue;\n  }\n\n  return coercedValues;\n}\n/**\n * Prepares an object map of argument values given a list of argument\n * definitions and list of argument AST nodes.\n *\n * Note: The returned value is a plain Object with a prototype, since it is\n * exposed to user code. Care should be taken to not pull values from the\n * Object prototype.\n *\n * @internal\n */\n\n\nexport function getArgumentValues(def, node, variableValues) {\n  var _node$arguments;\n\n  var coercedValues = {}; // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')\n\n  var argumentNodes = (_node$arguments = node.arguments) !== null && _node$arguments !== void 0 ? _node$arguments : [];\n  var argNodeMap = keyMap(argumentNodes, function (arg) {\n    return arg.name.value;\n  });\n\n  for (var _i4 = 0, _def$args2 = def.args; _i4 < _def$args2.length; _i4++) {\n    var argDef = _def$args2[_i4];\n    var name = argDef.name;\n    var argType = argDef.type;\n    var argumentNode = argNodeMap[name];\n\n    if (!argumentNode) {\n      if (argDef.defaultValue !== undefined) {\n        coercedValues[name] = argDef.defaultValue;\n      } else if (isNonNullType(argType)) {\n        throw new GraphQLError(\"Argument \\\"\".concat(name, \"\\\" of required type \\\"\").concat(inspect(argType), \"\\\" \") + 'was not provided.', node);\n      }\n\n      continue;\n    }\n\n    var valueNode = argumentNode.value;\n    var isNull = valueNode.kind === Kind.NULL;\n\n    if (valueNode.kind === Kind.VARIABLE) {\n      var variableName = valueNode.name.value;\n\n      if (variableValues == null || !hasOwnProperty(variableValues, variableName)) {\n        if (argDef.defaultValue !== undefined) {\n          coercedValues[name] = argDef.defaultValue;\n        } else if (isNonNullType(argType)) {\n          throw new GraphQLError(\"Argument \\\"\".concat(name, \"\\\" of required type \\\"\").concat(inspect(argType), \"\\\" \") + \"was provided the variable \\\"$\".concat(variableName, \"\\\" which was not provided a runtime value.\"), valueNode);\n        }\n\n        continue;\n      }\n\n      isNull = variableValues[variableName] == null;\n    }\n\n    if (isNull && isNonNullType(argType)) {\n      throw new GraphQLError(\"Argument \\\"\".concat(name, \"\\\" of non-null type \\\"\").concat(inspect(argType), \"\\\" \") + 'must not be null.', valueNode);\n    }\n\n    var coercedValue = valueFromAST(valueNode, argType, variableValues);\n\n    if (coercedValue === undefined) {\n      // Note: ValuesOfCorrectTypeRule validation should catch this before\n      // execution. This is a runtime check to ensure execution does not\n      // continue with an invalid argument value.\n      throw new GraphQLError(\"Argument \\\"\".concat(name, \"\\\" has invalid value \").concat(print(valueNode), \".\"), valueNode);\n    }\n\n    coercedValues[name] = coercedValue;\n  }\n\n  return coercedValues;\n}\n/**\n * Prepares an object map of argument values given a directive definition\n * and a AST node which may contain directives. Optionally also accepts a map\n * of variable values.\n *\n * If the directive does not exist on the node, returns undefined.\n *\n * Note: The returned value is a plain Object with a prototype, since it is\n * exposed to user code. Care should be taken to not pull values from the\n * Object prototype.\n */\n\nexport function getDirectiveValues(directiveDef, node, variableValues) {\n  var directiveNode = node.directives && find(node.directives, function (directive) {\n    return directive.name.value === directiveDef.name;\n  });\n\n  if (directiveNode) {\n    return getArgumentValues(directiveDef, directiveNode, variableValues);\n  }\n}\n\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n","import inspect from \"../jsutils/inspect.mjs\";\nimport memoize3 from \"../jsutils/memoize3.mjs\";\nimport invariant from \"../jsutils/invariant.mjs\";\nimport devAssert from \"../jsutils/devAssert.mjs\";\nimport isPromise from \"../jsutils/isPromise.mjs\";\nimport isObjectLike from \"../jsutils/isObjectLike.mjs\";\nimport safeArrayFrom from \"../jsutils/safeArrayFrom.mjs\";\nimport promiseReduce from \"../jsutils/promiseReduce.mjs\";\nimport promiseForObject from \"../jsutils/promiseForObject.mjs\";\nimport { addPath, pathToArray } from \"../jsutils/Path.mjs\";\nimport { GraphQLError } from \"../error/GraphQLError.mjs\";\nimport { locatedError } from \"../error/locatedError.mjs\";\nimport { Kind } from \"../language/kinds.mjs\";\nimport { assertValidSchema } from \"../type/validate.mjs\";\nimport { SchemaMetaFieldDef, TypeMetaFieldDef, TypeNameMetaFieldDef } from \"../type/introspection.mjs\";\nimport { GraphQLIncludeDirective, GraphQLSkipDirective } from \"../type/directives.mjs\";\nimport { isNamedType, isObjectType, isAbstractType, isLeafType, isListType, isNonNullType } from \"../type/definition.mjs\";\nimport { typeFromAST } from \"../utilities/typeFromAST.mjs\";\nimport { getOperationRootType } from \"../utilities/getOperationRootType.mjs\";\nimport { getVariableValues, getArgumentValues, getDirectiveValues } from \"./values.mjs\";\n/**\n * Terminology\n *\n * \"Definitions\" are the generic name for top-level statements in the document.\n * Examples of this include:\n * 1) Operations (such as a query)\n * 2) Fragments\n *\n * \"Operations\" are a generic name for requests in the document.\n * Examples of this include:\n * 1) query,\n * 2) mutation\n *\n * \"Selections\" are the definitions that can appear legally and at\n * single level of the query. These include:\n * 1) field references e.g \"a\"\n * 2) fragment \"spreads\" e.g. \"...c\"\n * 3) inline fragment \"spreads\" e.g. \"...on Type { a }\"\n */\n\n/**\n * Data that must be available at all points during query execution.\n *\n * Namely, schema of the type system that is currently executing,\n * and the fragments defined in the query document\n */\n\nexport function execute(argsOrSchema, document, rootValue, contextValue, variableValues, operationName, fieldResolver, typeResolver) {\n  /* eslint-enable no-redeclare */\n  // Extract arguments from object args if provided.\n  return arguments.length === 1 ? executeImpl(argsOrSchema) : executeImpl({\n    schema: argsOrSchema,\n    document: document,\n    rootValue: rootValue,\n    contextValue: contextValue,\n    variableValues: variableValues,\n    operationName: operationName,\n    fieldResolver: fieldResolver,\n    typeResolver: typeResolver\n  });\n}\n/**\n * Also implements the \"Evaluating requests\" section of the GraphQL specification.\n * However, it guarantees to complete synchronously (or throw an error) assuming\n * that all field resolvers are also synchronous.\n */\n\nexport function executeSync(args) {\n  var result = executeImpl(args); // Assert that the execution was synchronous.\n\n  if (isPromise(result)) {\n    throw new Error('GraphQL execution failed to complete synchronously.');\n  }\n\n  return result;\n}\n\nfunction executeImpl(args) {\n  var schema = args.schema,\n      document = args.document,\n      rootValue = args.rootValue,\n      contextValue = args.contextValue,\n      variableValues = args.variableValues,\n      operationName = args.operationName,\n      fieldResolver = args.fieldResolver,\n      typeResolver = args.typeResolver; // If arguments are missing or incorrect, throw an error.\n\n  assertValidExecutionArguments(schema, document, variableValues); // If a valid execution context cannot be created due to incorrect arguments,\n  // a \"Response\" with only errors is returned.\n\n  var exeContext = buildExecutionContext(schema, document, rootValue, contextValue, variableValues, operationName, fieldResolver, typeResolver); // Return early errors if execution context failed.\n\n  if (Array.isArray(exeContext)) {\n    return {\n      errors: exeContext\n    };\n  } // Return a Promise that will eventually resolve to the data described by\n  // The \"Response\" section of the GraphQL specification.\n  //\n  // If errors are encountered while executing a GraphQL field, only that\n  // field and its descendants will be omitted, and sibling fields will still\n  // be executed. An execution which encounters errors will still result in a\n  // resolved Promise.\n\n\n  var data = executeOperation(exeContext, exeContext.operation, rootValue);\n  return buildResponse(exeContext, data);\n}\n/**\n * Given a completed execution context and data, build the { errors, data }\n * response defined by the \"Response\" section of the GraphQL specification.\n */\n\n\nfunction buildResponse(exeContext, data) {\n  if (isPromise(data)) {\n    return data.then(function (resolved) {\n      return buildResponse(exeContext, resolved);\n    });\n  }\n\n  return exeContext.errors.length === 0 ? {\n    data: data\n  } : {\n    errors: exeContext.errors,\n    data: data\n  };\n}\n/**\n * Essential assertions before executing to provide developer feedback for\n * improper use of the GraphQL library.\n *\n * @internal\n */\n\n\nexport function assertValidExecutionArguments(schema, document, rawVariableValues) {\n  document || devAssert(0, 'Must provide document.'); // If the schema used for execution is invalid, throw an error.\n\n  assertValidSchema(schema); // Variables, if provided, must be an object.\n\n  rawVariableValues == null || isObjectLike(rawVariableValues) || devAssert(0, 'Variables must be provided as an Object where each property is a variable value. Perhaps look to see if an unparsed JSON string was provided.');\n}\n/**\n * Constructs a ExecutionContext object from the arguments passed to\n * execute, which we will pass throughout the other execution methods.\n *\n * Throws a GraphQLError if a valid execution context cannot be created.\n *\n * @internal\n */\n\nexport function buildExecutionContext(schema, document, rootValue, contextValue, rawVariableValues, operationName, fieldResolver, typeResolver) {\n  var _definition$name, _operation$variableDe;\n\n  var operation;\n  var fragments = Object.create(null);\n\n  for (var _i2 = 0, _document$definitions2 = document.definitions; _i2 < _document$definitions2.length; _i2++) {\n    var definition = _document$definitions2[_i2];\n\n    switch (definition.kind) {\n      case Kind.OPERATION_DEFINITION:\n        if (operationName == null) {\n          if (operation !== undefined) {\n            return [new GraphQLError('Must provide operation name if query contains multiple operations.')];\n          }\n\n          operation = definition;\n        } else if (((_definition$name = definition.name) === null || _definition$name === void 0 ? void 0 : _definition$name.value) === operationName) {\n          operation = definition;\n        }\n\n        break;\n\n      case Kind.FRAGMENT_DEFINITION:\n        fragments[definition.name.value] = definition;\n        break;\n    }\n  }\n\n  if (!operation) {\n    if (operationName != null) {\n      return [new GraphQLError(\"Unknown operation named \\\"\".concat(operationName, \"\\\".\"))];\n    }\n\n    return [new GraphQLError('Must provide an operation.')];\n  } // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')\n\n\n  var variableDefinitions = (_operation$variableDe = operation.variableDefinitions) !== null && _operation$variableDe !== void 0 ? _operation$variableDe : [];\n  var coercedVariableValues = getVariableValues(schema, variableDefinitions, rawVariableValues !== null && rawVariableValues !== void 0 ? rawVariableValues : {}, {\n    maxErrors: 50\n  });\n\n  if (coercedVariableValues.errors) {\n    return coercedVariableValues.errors;\n  }\n\n  return {\n    schema: schema,\n    fragments: fragments,\n    rootValue: rootValue,\n    contextValue: contextValue,\n    operation: operation,\n    variableValues: coercedVariableValues.coerced,\n    fieldResolver: fieldResolver !== null && fieldResolver !== void 0 ? fieldResolver : defaultFieldResolver,\n    typeResolver: typeResolver !== null && typeResolver !== void 0 ? typeResolver : defaultTypeResolver,\n    errors: []\n  };\n}\n/**\n * Implements the \"Evaluating operations\" section of the spec.\n */\n\nfunction executeOperation(exeContext, operation, rootValue) {\n  var type = getOperationRootType(exeContext.schema, operation);\n  var fields = collectFields(exeContext, type, operation.selectionSet, Object.create(null), Object.create(null));\n  var path = undefined; // Errors from sub-fields of a NonNull type may propagate to the top level,\n  // at which point we still log the error and null the parent field, which\n  // in this case is the entire response.\n\n  try {\n    var result = operation.operation === 'mutation' ? executeFieldsSerially(exeContext, type, rootValue, path, fields) : executeFields(exeContext, type, rootValue, path, fields);\n\n    if (isPromise(result)) {\n      return result.then(undefined, function (error) {\n        exeContext.errors.push(error);\n        return Promise.resolve(null);\n      });\n    }\n\n    return result;\n  } catch (error) {\n    exeContext.errors.push(error);\n    return null;\n  }\n}\n/**\n * Implements the \"Evaluating selection sets\" section of the spec\n * for \"write\" mode.\n */\n\n\nfunction executeFieldsSerially(exeContext, parentType, sourceValue, path, fields) {\n  return promiseReduce(Object.keys(fields), function (results, responseName) {\n    var fieldNodes = fields[responseName];\n    var fieldPath = addPath(path, responseName, parentType.name);\n    var result = resolveField(exeContext, parentType, sourceValue, fieldNodes, fieldPath);\n\n    if (result === undefined) {\n      return results;\n    }\n\n    if (isPromise(result)) {\n      return result.then(function (resolvedResult) {\n        results[responseName] = resolvedResult;\n        return results;\n      });\n    }\n\n    results[responseName] = result;\n    return results;\n  }, Object.create(null));\n}\n/**\n * Implements the \"Evaluating selection sets\" section of the spec\n * for \"read\" mode.\n */\n\n\nfunction executeFields(exeContext, parentType, sourceValue, path, fields) {\n  var results = Object.create(null);\n  var containsPromise = false;\n\n  for (var _i4 = 0, _Object$keys2 = Object.keys(fields); _i4 < _Object$keys2.length; _i4++) {\n    var responseName = _Object$keys2[_i4];\n    var fieldNodes = fields[responseName];\n    var fieldPath = addPath(path, responseName, parentType.name);\n    var result = resolveField(exeContext, parentType, sourceValue, fieldNodes, fieldPath);\n\n    if (result !== undefined) {\n      results[responseName] = result;\n\n      if (isPromise(result)) {\n        containsPromise = true;\n      }\n    }\n  } // If there are no promises, we can just return the object\n\n\n  if (!containsPromise) {\n    return results;\n  } // Otherwise, results is a map from field name to the result of resolving that\n  // field, which is possibly a promise. Return a promise that will return this\n  // same map, but with any promises replaced with the values they resolved to.\n\n\n  return promiseForObject(results);\n}\n/**\n * Given a selectionSet, adds all of the fields in that selection to\n * the passed in map of fields, and returns it at the end.\n *\n * CollectFields requires the \"runtime type\" of an object. For a field which\n * returns an Interface or Union type, the \"runtime type\" will be the actual\n * Object type returned by that field.\n *\n * @internal\n */\n\n\nexport function collectFields(exeContext, runtimeType, selectionSet, fields, visitedFragmentNames) {\n  for (var _i6 = 0, _selectionSet$selecti2 = selectionSet.selections; _i6 < _selectionSet$selecti2.length; _i6++) {\n    var selection = _selectionSet$selecti2[_i6];\n\n    switch (selection.kind) {\n      case Kind.FIELD:\n        {\n          if (!shouldIncludeNode(exeContext, selection)) {\n            continue;\n          }\n\n          var name = getFieldEntryKey(selection);\n\n          if (!fields[name]) {\n            fields[name] = [];\n          }\n\n          fields[name].push(selection);\n          break;\n        }\n\n      case Kind.INLINE_FRAGMENT:\n        {\n          if (!shouldIncludeNode(exeContext, selection) || !doesFragmentConditionMatch(exeContext, selection, runtimeType)) {\n            continue;\n          }\n\n          collectFields(exeContext, runtimeType, selection.selectionSet, fields, visitedFragmentNames);\n          break;\n        }\n\n      case Kind.FRAGMENT_SPREAD:\n        {\n          var fragName = selection.name.value;\n\n          if (visitedFragmentNames[fragName] || !shouldIncludeNode(exeContext, selection)) {\n            continue;\n          }\n\n          visitedFragmentNames[fragName] = true;\n          var fragment = exeContext.fragments[fragName];\n\n          if (!fragment || !doesFragmentConditionMatch(exeContext, fragment, runtimeType)) {\n            continue;\n          }\n\n          collectFields(exeContext, runtimeType, fragment.selectionSet, fields, visitedFragmentNames);\n          break;\n        }\n    }\n  }\n\n  return fields;\n}\n/**\n * Determines if a field should be included based on the @include and @skip\n * directives, where @skip has higher precedence than @include.\n */\n\nfunction shouldIncludeNode(exeContext, node) {\n  var skip = getDirectiveValues(GraphQLSkipDirective, node, exeContext.variableValues);\n\n  if ((skip === null || skip === void 0 ? void 0 : skip.if) === true) {\n    return false;\n  }\n\n  var include = getDirectiveValues(GraphQLIncludeDirective, node, exeContext.variableValues);\n\n  if ((include === null || include === void 0 ? void 0 : include.if) === false) {\n    return false;\n  }\n\n  return true;\n}\n/**\n * Determines if a fragment is applicable to the given type.\n */\n\n\nfunction doesFragmentConditionMatch(exeContext, fragment, type) {\n  var typeConditionNode = fragment.typeCondition;\n\n  if (!typeConditionNode) {\n    return true;\n  }\n\n  var conditionalType = typeFromAST(exeContext.schema, typeConditionNode);\n\n  if (conditionalType === type) {\n    return true;\n  }\n\n  if (isAbstractType(conditionalType)) {\n    return exeContext.schema.isSubType(conditionalType, type);\n  }\n\n  return false;\n}\n/**\n * Implements the logic to compute the key of a given field's entry\n */\n\n\nfunction getFieldEntryKey(node) {\n  return node.alias ? node.alias.value : node.name.value;\n}\n/**\n * Resolves the field on the given source object. In particular, this\n * figures out the value that the field returns by calling its resolve function,\n * then calls completeValue to complete promises, serialize scalars, or execute\n * the sub-selection-set for objects.\n */\n\n\nfunction resolveField(exeContext, parentType, source, fieldNodes, path) {\n  var _fieldDef$resolve;\n\n  var fieldNode = fieldNodes[0];\n  var fieldName = fieldNode.name.value;\n  var fieldDef = getFieldDef(exeContext.schema, parentType, fieldName);\n\n  if (!fieldDef) {\n    return;\n  }\n\n  var returnType = fieldDef.type;\n  var resolveFn = (_fieldDef$resolve = fieldDef.resolve) !== null && _fieldDef$resolve !== void 0 ? _fieldDef$resolve : exeContext.fieldResolver;\n  var info = buildResolveInfo(exeContext, fieldDef, fieldNodes, parentType, path); // Get the resolve function, regardless of if its result is normal or abrupt (error).\n\n  try {\n    // Build a JS object of arguments from the field.arguments AST, using the\n    // variables scope to fulfill any variable references.\n    // TODO: find a way to memoize, in case this field is within a List type.\n    var args = getArgumentValues(fieldDef, fieldNodes[0], exeContext.variableValues); // The resolve function's optional third argument is a context value that\n    // is provided to every resolve function within an execution. It is commonly\n    // used to represent an authenticated user, or request-specific caches.\n\n    var _contextValue = exeContext.contextValue;\n    var result = resolveFn(source, args, _contextValue, info);\n    var completed;\n\n    if (isPromise(result)) {\n      completed = result.then(function (resolved) {\n        return completeValue(exeContext, returnType, fieldNodes, info, path, resolved);\n      });\n    } else {\n      completed = completeValue(exeContext, returnType, fieldNodes, info, path, result);\n    }\n\n    if (isPromise(completed)) {\n      // Note: we don't rely on a `catch` method, but we do expect \"thenable\"\n      // to take a second callback for the error case.\n      return completed.then(undefined, function (rawError) {\n        var error = locatedError(rawError, fieldNodes, pathToArray(path));\n        return handleFieldError(error, returnType, exeContext);\n      });\n    }\n\n    return completed;\n  } catch (rawError) {\n    var error = locatedError(rawError, fieldNodes, pathToArray(path));\n    return handleFieldError(error, returnType, exeContext);\n  }\n}\n/**\n * @internal\n */\n\n\nexport function buildResolveInfo(exeContext, fieldDef, fieldNodes, parentType, path) {\n  // The resolve function's optional fourth argument is a collection of\n  // information about the current execution state.\n  return {\n    fieldName: fieldDef.name,\n    fieldNodes: fieldNodes,\n    returnType: fieldDef.type,\n    parentType: parentType,\n    path: path,\n    schema: exeContext.schema,\n    fragments: exeContext.fragments,\n    rootValue: exeContext.rootValue,\n    operation: exeContext.operation,\n    variableValues: exeContext.variableValues\n  };\n}\n\nfunction handleFieldError(error, returnType, exeContext) {\n  // If the field type is non-nullable, then it is resolved without any\n  // protection from errors, however it still properly locates the error.\n  if (isNonNullType(returnType)) {\n    throw error;\n  } // Otherwise, error protection is applied, logging the error and resolving\n  // a null value for this field if one is encountered.\n\n\n  exeContext.errors.push(error);\n  return null;\n}\n/**\n * Implements the instructions for completeValue as defined in the\n * \"Field entries\" section of the spec.\n *\n * If the field type is Non-Null, then this recursively completes the value\n * for the inner type. It throws a field error if that completion returns null,\n * as per the \"Nullability\" section of the spec.\n *\n * If the field type is a List, then this recursively completes the value\n * for the inner type on each item in the list.\n *\n * If the field type is a Scalar or Enum, ensures the completed value is a legal\n * value of the type by calling the `serialize` method of GraphQL type\n * definition.\n *\n * If the field is an abstract type, determine the runtime type of the value\n * and then complete based on that type\n *\n * Otherwise, the field type expects a sub-selection set, and will complete the\n * value by evaluating all sub-selections.\n */\n\n\nfunction completeValue(exeContext, returnType, fieldNodes, info, path, result) {\n  // If result is an Error, throw a located error.\n  if (result instanceof Error) {\n    throw result;\n  } // If field type is NonNull, complete for inner type, and throw field error\n  // if result is null.\n\n\n  if (isNonNullType(returnType)) {\n    var completed = completeValue(exeContext, returnType.ofType, fieldNodes, info, path, result);\n\n    if (completed === null) {\n      throw new Error(\"Cannot return null for non-nullable field \".concat(info.parentType.name, \".\").concat(info.fieldName, \".\"));\n    }\n\n    return completed;\n  } // If result value is null or undefined then return null.\n\n\n  if (result == null) {\n    return null;\n  } // If field type is List, complete each item in the list with the inner type\n\n\n  if (isListType(returnType)) {\n    return completeListValue(exeContext, returnType, fieldNodes, info, path, result);\n  } // If field type is a leaf type, Scalar or Enum, serialize to a valid value,\n  // returning null if serialization is not possible.\n\n\n  if (isLeafType(returnType)) {\n    return completeLeafValue(returnType, result);\n  } // If field type is an abstract type, Interface or Union, determine the\n  // runtime Object type and complete for that type.\n\n\n  if (isAbstractType(returnType)) {\n    return completeAbstractValue(exeContext, returnType, fieldNodes, info, path, result);\n  } // If field type is Object, execute and complete all sub-selections.\n  // istanbul ignore else (See: 'https://github.com/graphql/graphql-js/issues/2618')\n\n\n  if (isObjectType(returnType)) {\n    return completeObjectValue(exeContext, returnType, fieldNodes, info, path, result);\n  } // istanbul ignore next (Not reachable. All possible output types have been considered)\n\n\n  false || invariant(0, 'Cannot complete value of unexpected output type: ' + inspect(returnType));\n}\n/**\n * Complete a list value by completing each item in the list with the\n * inner type\n */\n\n\nfunction completeListValue(exeContext, returnType, fieldNodes, info, path, result) {\n  // This is specified as a simple map, however we're optimizing the path\n  // where the list contains no Promises by avoiding creating another Promise.\n  var itemType = returnType.ofType;\n  var containsPromise = false;\n  var completedResults = safeArrayFrom(result, function (item, index) {\n    // No need to modify the info object containing the path,\n    // since from here on it is not ever accessed by resolver functions.\n    var itemPath = addPath(path, index, undefined);\n\n    try {\n      var completedItem;\n\n      if (isPromise(item)) {\n        completedItem = item.then(function (resolved) {\n          return completeValue(exeContext, itemType, fieldNodes, info, itemPath, resolved);\n        });\n      } else {\n        completedItem = completeValue(exeContext, itemType, fieldNodes, info, itemPath, item);\n      }\n\n      if (isPromise(completedItem)) {\n        containsPromise = true; // Note: we don't rely on a `catch` method, but we do expect \"thenable\"\n        // to take a second callback for the error case.\n\n        return completedItem.then(undefined, function (rawError) {\n          var error = locatedError(rawError, fieldNodes, pathToArray(itemPath));\n          return handleFieldError(error, itemType, exeContext);\n        });\n      }\n\n      return completedItem;\n    } catch (rawError) {\n      var error = locatedError(rawError, fieldNodes, pathToArray(itemPath));\n      return handleFieldError(error, itemType, exeContext);\n    }\n  });\n\n  if (completedResults == null) {\n    throw new GraphQLError(\"Expected Iterable, but did not find one for field \\\"\".concat(info.parentType.name, \".\").concat(info.fieldName, \"\\\".\"));\n  }\n\n  return containsPromise ? Promise.all(completedResults) : completedResults;\n}\n/**\n * Complete a Scalar or Enum by serializing to a valid value, returning\n * null if serialization is not possible.\n */\n\n\nfunction completeLeafValue(returnType, result) {\n  var serializedResult = returnType.serialize(result);\n\n  if (serializedResult === undefined) {\n    throw new Error(\"Expected a value of type \\\"\".concat(inspect(returnType), \"\\\" but \") + \"received: \".concat(inspect(result)));\n  }\n\n  return serializedResult;\n}\n/**\n * Complete a value of an abstract type by determining the runtime object type\n * of that value, then complete the value for that type.\n */\n\n\nfunction completeAbstractValue(exeContext, returnType, fieldNodes, info, path, result) {\n  var _returnType$resolveTy;\n\n  var resolveTypeFn = (_returnType$resolveTy = returnType.resolveType) !== null && _returnType$resolveTy !== void 0 ? _returnType$resolveTy : exeContext.typeResolver;\n  var contextValue = exeContext.contextValue;\n  var runtimeType = resolveTypeFn(result, contextValue, info, returnType);\n\n  if (isPromise(runtimeType)) {\n    return runtimeType.then(function (resolvedRuntimeType) {\n      return completeObjectValue(exeContext, ensureValidRuntimeType(resolvedRuntimeType, exeContext, returnType, fieldNodes, info, result), fieldNodes, info, path, result);\n    });\n  }\n\n  return completeObjectValue(exeContext, ensureValidRuntimeType(runtimeType, exeContext, returnType, fieldNodes, info, result), fieldNodes, info, path, result);\n}\n\nfunction ensureValidRuntimeType(runtimeTypeOrName, exeContext, returnType, fieldNodes, info, result) {\n  if (runtimeTypeOrName == null) {\n    throw new GraphQLError(\"Abstract type \\\"\".concat(returnType.name, \"\\\" must resolve to an Object type at runtime for field \\\"\").concat(info.parentType.name, \".\").concat(info.fieldName, \"\\\". Either the \\\"\").concat(returnType.name, \"\\\" type should provide a \\\"resolveType\\\" function or each possible type should provide an \\\"isTypeOf\\\" function.\"), fieldNodes);\n  } // FIXME: temporary workaround until support for passing object types would be removed in v16.0.0\n\n\n  var runtimeTypeName = isNamedType(runtimeTypeOrName) ? runtimeTypeOrName.name : runtimeTypeOrName;\n\n  if (typeof runtimeTypeName !== 'string') {\n    throw new GraphQLError(\"Abstract type \\\"\".concat(returnType.name, \"\\\" must resolve to an Object type at runtime for field \\\"\").concat(info.parentType.name, \".\").concat(info.fieldName, \"\\\" with \") + \"value \".concat(inspect(result), \", received \\\"\").concat(inspect(runtimeTypeOrName), \"\\\".\"));\n  }\n\n  var runtimeType = exeContext.schema.getType(runtimeTypeName);\n\n  if (runtimeType == null) {\n    throw new GraphQLError(\"Abstract type \\\"\".concat(returnType.name, \"\\\" was resolve to a type \\\"\").concat(runtimeTypeName, \"\\\" that does not exist inside schema.\"), fieldNodes);\n  }\n\n  if (!isObjectType(runtimeType)) {\n    throw new GraphQLError(\"Abstract type \\\"\".concat(returnType.name, \"\\\" was resolve to a non-object type \\\"\").concat(runtimeTypeName, \"\\\".\"), fieldNodes);\n  }\n\n  if (!exeContext.schema.isSubType(returnType, runtimeType)) {\n    throw new GraphQLError(\"Runtime Object type \\\"\".concat(runtimeType.name, \"\\\" is not a possible type for \\\"\").concat(returnType.name, \"\\\".\"), fieldNodes);\n  }\n\n  return runtimeType;\n}\n/**\n * Complete an Object value by executing all sub-selections.\n */\n\n\nfunction completeObjectValue(exeContext, returnType, fieldNodes, info, path, result) {\n  // If there is an isTypeOf predicate function, call it with the\n  // current result. If isTypeOf returns false, then raise an error rather\n  // than continuing execution.\n  if (returnType.isTypeOf) {\n    var isTypeOf = returnType.isTypeOf(result, exeContext.contextValue, info);\n\n    if (isPromise(isTypeOf)) {\n      return isTypeOf.then(function (resolvedIsTypeOf) {\n        if (!resolvedIsTypeOf) {\n          throw invalidReturnTypeError(returnType, result, fieldNodes);\n        }\n\n        return collectAndExecuteSubfields(exeContext, returnType, fieldNodes, path, result);\n      });\n    }\n\n    if (!isTypeOf) {\n      throw invalidReturnTypeError(returnType, result, fieldNodes);\n    }\n  }\n\n  return collectAndExecuteSubfields(exeContext, returnType, fieldNodes, path, result);\n}\n\nfunction invalidReturnTypeError(returnType, result, fieldNodes) {\n  return new GraphQLError(\"Expected value of type \\\"\".concat(returnType.name, \"\\\" but got: \").concat(inspect(result), \".\"), fieldNodes);\n}\n\nfunction collectAndExecuteSubfields(exeContext, returnType, fieldNodes, path, result) {\n  // Collect sub-fields to execute to complete this value.\n  var subFieldNodes = collectSubfields(exeContext, returnType, fieldNodes);\n  return executeFields(exeContext, returnType, result, path, subFieldNodes);\n}\n/**\n * A memoized collection of relevant subfields with regard to the return\n * type. Memoizing ensures the subfields are not repeatedly calculated, which\n * saves overhead when resolving lists of values.\n */\n\n\nvar collectSubfields = memoize3(_collectSubfields);\n\nfunction _collectSubfields(exeContext, returnType, fieldNodes) {\n  var subFieldNodes = Object.create(null);\n  var visitedFragmentNames = Object.create(null);\n\n  for (var _i8 = 0; _i8 < fieldNodes.length; _i8++) {\n    var node = fieldNodes[_i8];\n\n    if (node.selectionSet) {\n      subFieldNodes = collectFields(exeContext, returnType, node.selectionSet, subFieldNodes, visitedFragmentNames);\n    }\n  }\n\n  return subFieldNodes;\n}\n/**\n * If a resolveType function is not given, then a default resolve behavior is\n * used which attempts two strategies:\n *\n * First, See if the provided value has a `__typename` field defined, if so, use\n * that value as name of the resolved type.\n *\n * Otherwise, test each possible type for the abstract type by calling\n * isTypeOf for the object being coerced, returning the first type that matches.\n */\n\n\nexport var defaultTypeResolver = function defaultTypeResolver(value, contextValue, info, abstractType) {\n  // First, look for `__typename`.\n  if (isObjectLike(value) && typeof value.__typename === 'string') {\n    return value.__typename;\n  } // Otherwise, test each possible type.\n\n\n  var possibleTypes = info.schema.getPossibleTypes(abstractType);\n  var promisedIsTypeOfResults = [];\n\n  for (var i = 0; i < possibleTypes.length; i++) {\n    var type = possibleTypes[i];\n\n    if (type.isTypeOf) {\n      var isTypeOfResult = type.isTypeOf(value, contextValue, info);\n\n      if (isPromise(isTypeOfResult)) {\n        promisedIsTypeOfResults[i] = isTypeOfResult;\n      } else if (isTypeOfResult) {\n        return type.name;\n      }\n    }\n  }\n\n  if (promisedIsTypeOfResults.length) {\n    return Promise.all(promisedIsTypeOfResults).then(function (isTypeOfResults) {\n      for (var _i9 = 0; _i9 < isTypeOfResults.length; _i9++) {\n        if (isTypeOfResults[_i9]) {\n          return possibleTypes[_i9].name;\n        }\n      }\n    });\n  }\n};\n/**\n * If a resolve function is not given, then a default resolve behavior is used\n * which takes the property of the source object of the same name as the field\n * and returns it as the result, or if it's a function, returns the result\n * of calling that function while passing along args and context value.\n */\n\nexport var defaultFieldResolver = function defaultFieldResolver(source, args, contextValue, info) {\n  // ensure source is a value for which property access is acceptable.\n  if (isObjectLike(source) || typeof source === 'function') {\n    var property = source[info.fieldName];\n\n    if (typeof property === 'function') {\n      return source[info.fieldName](args, contextValue, info);\n    }\n\n    return property;\n  }\n};\n/**\n * This method looks up the field on the given type definition.\n * It has special casing for the three introspection fields,\n * __schema, __type and __typename. __typename is special because\n * it can always be queried as a field, even in situations where no\n * other fields are allowed, like on a Union. __schema and __type\n * could get automatically added to the query type, but that would\n * require mutating type definitions, which would cause issues.\n *\n * @internal\n */\n\nexport function getFieldDef(schema, parentType, fieldName) {\n  if (fieldName === SchemaMetaFieldDef.name && schema.getQueryType() === parentType) {\n    return SchemaMetaFieldDef;\n  } else if (fieldName === TypeMetaFieldDef.name && schema.getQueryType() === parentType) {\n    return TypeMetaFieldDef;\n  } else if (fieldName === TypeNameMetaFieldDef.name) {\n    return TypeNameMetaFieldDef;\n  }\n\n  return parentType.getFields()[fieldName];\n}\n","import isPromise from \"./isPromise.mjs\";\n/**\n * Similar to Array.prototype.reduce(), however the reducing callback may return\n * a Promise, in which case reduction will continue after each promise resolves.\n *\n * If the callback does not return a Promise, then this function will also not\n * return a Promise.\n */\n\nexport default function promiseReduce(values, callback, initialValue) {\n  return values.reduce(function (previous, value) {\n    return isPromise(previous) ? previous.then(function (resolved) {\n      return callback(resolved, value);\n    }) : callback(previous, value);\n  }, initialValue);\n}\n","/**\n * This function transforms a JS object `ObjMap<Promise<T>>` into\n * a `Promise<ObjMap<T>>`\n *\n * This is akin to bluebird's `Promise.props`, but implemented only using\n * `Promise.all` so it will work with any implementation of ES6 promises.\n */\nexport default function promiseForObject(object) {\n  var keys = Object.keys(object);\n  var valuesAndPromises = keys.map(function (name) {\n    return object[name];\n  });\n  return Promise.all(valuesAndPromises).then(function (values) {\n    return values.reduce(function (resolvedObject, value, i) {\n      resolvedObject[keys[i]] = value;\n      return resolvedObject;\n    }, Object.create(null));\n  });\n}\n","/**\n * Memoizes the provided three-argument function.\n */\nexport default function memoize3(fn) {\n  var cache0;\n  return function memoized(a1, a2, a3) {\n    if (!cache0) {\n      cache0 = new WeakMap();\n    }\n\n    var cache1 = cache0.get(a1);\n    var cache2;\n\n    if (cache1) {\n      cache2 = cache1.get(a2);\n\n      if (cache2) {\n        var cachedValue = cache2.get(a3);\n\n        if (cachedValue !== undefined) {\n          return cachedValue;\n        }\n      }\n    } else {\n      cache1 = new WeakMap();\n      cache0.set(a1, cache1);\n    }\n\n    if (!cache2) {\n      cache2 = new WeakMap();\n      cache1.set(a2, cache2);\n    }\n\n    var newValue = fn(a1, a2, a3);\n    cache2.set(a3, newValue);\n    return newValue;\n  };\n}\n","import isPromise from \"./jsutils/isPromise.mjs\";\nimport { parse } from \"./language/parser.mjs\";\nimport { validate } from \"./validation/validate.mjs\";\nimport { validateSchema } from \"./type/validate.mjs\";\nimport { execute } from \"./execution/execute.mjs\";\n/**\n * This is the primary entry point function for fulfilling GraphQL operations\n * by parsing, validating, and executing a GraphQL document along side a\n * GraphQL schema.\n *\n * More sophisticated GraphQL servers, such as those which persist queries,\n * may wish to separate the validation and execution phases to a static time\n * tooling step, and a server runtime step.\n *\n * Accepts either an object with named arguments, or individual arguments:\n *\n * schema:\n *    The GraphQL type system to use when validating and executing a query.\n * source:\n *    A GraphQL language formatted string representing the requested operation.\n * rootValue:\n *    The value provided as the first argument to resolver functions on the top\n *    level type (e.g. the query object type).\n * contextValue:\n *    The context value is provided as an argument to resolver functions after\n *    field arguments. It is used to pass shared information useful at any point\n *    during executing this query, for example the currently logged in user and\n *    connections to databases or other services.\n * variableValues:\n *    A mapping of variable name to runtime value to use for all variables\n *    defined in the requestString.\n * operationName:\n *    The name of the operation to use if requestString contains multiple\n *    possible operations. Can be omitted if requestString contains only\n *    one operation.\n * fieldResolver:\n *    A resolver function to use when one is not provided by the schema.\n *    If not provided, the default field resolver is used (which looks for a\n *    value or method on the source value with the field's name).\n * typeResolver:\n *    A type resolver function to use when none is provided by the schema.\n *    If not provided, the default type resolver is used (which looks for a\n *    `__typename` field or alternatively calls the `isTypeOf` method).\n */\n\nexport function graphql(argsOrSchema, source, rootValue, contextValue, variableValues, operationName, fieldResolver, typeResolver) {\n  var _arguments = arguments;\n\n  /* eslint-enable no-redeclare */\n  // Always return a Promise for a consistent API.\n  return new Promise(function (resolve) {\n    return resolve( // Extract arguments from object args if provided.\n    _arguments.length === 1 ? graphqlImpl(argsOrSchema) : graphqlImpl({\n      schema: argsOrSchema,\n      source: source,\n      rootValue: rootValue,\n      contextValue: contextValue,\n      variableValues: variableValues,\n      operationName: operationName,\n      fieldResolver: fieldResolver,\n      typeResolver: typeResolver\n    }));\n  });\n}\n/**\n * The graphqlSync function also fulfills GraphQL operations by parsing,\n * validating, and executing a GraphQL document along side a GraphQL schema.\n * However, it guarantees to complete synchronously (or throw an error) assuming\n * that all field resolvers are also synchronous.\n */\n\nexport function graphqlSync(argsOrSchema, source, rootValue, contextValue, variableValues, operationName, fieldResolver, typeResolver) {\n  /* eslint-enable no-redeclare */\n  // Extract arguments from object args if provided.\n  var result = arguments.length === 1 ? graphqlImpl(argsOrSchema) : graphqlImpl({\n    schema: argsOrSchema,\n    source: source,\n    rootValue: rootValue,\n    contextValue: contextValue,\n    variableValues: variableValues,\n    operationName: operationName,\n    fieldResolver: fieldResolver,\n    typeResolver: typeResolver\n  }); // Assert that the execution was synchronous.\n\n  if (isPromise(result)) {\n    throw new Error('GraphQL execution failed to complete synchronously.');\n  }\n\n  return result;\n}\n\nfunction graphqlImpl(args) {\n  var schema = args.schema,\n      source = args.source,\n      rootValue = args.rootValue,\n      contextValue = args.contextValue,\n      variableValues = args.variableValues,\n      operationName = args.operationName,\n      fieldResolver = args.fieldResolver,\n      typeResolver = args.typeResolver; // Validate Schema\n\n  var schemaValidationErrors = validateSchema(schema);\n\n  if (schemaValidationErrors.length > 0) {\n    return {\n      errors: schemaValidationErrors\n    };\n  } // Parse\n\n\n  var document;\n\n  try {\n    document = parse(source);\n  } catch (syntaxError) {\n    return {\n      errors: [syntaxError]\n    };\n  } // Validate\n\n\n  var validationErrors = validate(schema, document);\n\n  if (validationErrors.length > 0) {\n    return {\n      errors: validationErrors\n    };\n  } // Execute\n\n\n  return execute({\n    schema: schema,\n    document: document,\n    rootValue: rootValue,\n    contextValue: contextValue,\n    variableValues: variableValues,\n    operationName: operationName,\n    fieldResolver: fieldResolver,\n    typeResolver: typeResolver\n  });\n}\n","import { SYMBOL_ASYNC_ITERATOR } from \"../polyfills/symbols.mjs\";\n/**\n * Returns true if the provided object implements the AsyncIterator protocol via\n * either implementing a `Symbol.asyncIterator` or `\"@@asyncIterator\"` method.\n */\n\n// eslint-disable-next-line no-redeclare\nexport default function isAsyncIterable(maybeAsyncIterable) {\n  return typeof (maybeAsyncIterable === null || maybeAsyncIterable === void 0 ? void 0 : maybeAsyncIterable[SYMBOL_ASYNC_ITERATOR]) === 'function';\n}\n","function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { SYMBOL_ASYNC_ITERATOR } from \"../polyfills/symbols.mjs\";\n\n/**\n * Given an AsyncIterable and a callback function, return an AsyncIterator\n * which produces values mapped via calling the callback function.\n */\nexport default function mapAsyncIterator(iterable, callback, rejectCallback) {\n  // $FlowFixMe[prop-missing]\n  var iteratorMethod = iterable[SYMBOL_ASYNC_ITERATOR];\n  var iterator = iteratorMethod.call(iterable);\n  var $return;\n  var abruptClose;\n\n  if (typeof iterator.return === 'function') {\n    $return = iterator.return;\n\n    abruptClose = function abruptClose(error) {\n      var rethrow = function rethrow() {\n        return Promise.reject(error);\n      };\n\n      return $return.call(iterator).then(rethrow, rethrow);\n    };\n  }\n\n  function mapResult(result) {\n    return result.done ? result : asyncMapValue(result.value, callback).then(iteratorResult, abruptClose);\n  }\n\n  var mapReject;\n\n  if (rejectCallback) {\n    // Capture rejectCallback to ensure it cannot be null.\n    var reject = rejectCallback;\n\n    mapReject = function mapReject(error) {\n      return asyncMapValue(error, reject).then(iteratorResult, abruptClose);\n    };\n  }\n  /* TODO: Flow doesn't support symbols as keys:\n     https://github.com/facebook/flow/issues/3258 */\n\n\n  return _defineProperty({\n    next: function next() {\n      return iterator.next().then(mapResult, mapReject);\n    },\n    return: function _return() {\n      return $return ? $return.call(iterator).then(mapResult, mapReject) : Promise.resolve({\n        value: undefined,\n        done: true\n      });\n    },\n    throw: function _throw(error) {\n      if (typeof iterator.throw === 'function') {\n        return iterator.throw(error).then(mapResult, mapReject);\n      }\n\n      return Promise.reject(error).catch(abruptClose);\n    }\n  }, SYMBOL_ASYNC_ITERATOR, function () {\n    return this;\n  });\n}\n\nfunction asyncMapValue(value, callback) {\n  return new Promise(function (resolve) {\n    return resolve(callback(value));\n  });\n}\n\nfunction iteratorResult(value) {\n  return {\n    value: value,\n    done: false\n  };\n}\n","import inspect from \"../jsutils/inspect.mjs\";\nimport isAsyncIterable from \"../jsutils/isAsyncIterable.mjs\";\nimport { addPath, pathToArray } from \"../jsutils/Path.mjs\";\nimport { GraphQLError } from \"../error/GraphQLError.mjs\";\nimport { locatedError } from \"../error/locatedError.mjs\";\nimport { getArgumentValues } from \"../execution/values.mjs\";\nimport { assertValidExecutionArguments, buildExecutionContext, buildResolveInfo, collectFields, execute, getFieldDef } from \"../execution/execute.mjs\";\nimport { getOperationRootType } from \"../utilities/getOperationRootType.mjs\";\nimport mapAsyncIterator from \"./mapAsyncIterator.mjs\";\nexport function subscribe(argsOrSchema, document, rootValue, contextValue, variableValues, operationName, fieldResolver, subscribeFieldResolver) {\n  /* eslint-enable no-redeclare */\n  // Extract arguments from object args if provided.\n  return arguments.length === 1 ? subscribeImpl(argsOrSchema) : subscribeImpl({\n    schema: argsOrSchema,\n    document: document,\n    rootValue: rootValue,\n    contextValue: contextValue,\n    variableValues: variableValues,\n    operationName: operationName,\n    fieldResolver: fieldResolver,\n    subscribeFieldResolver: subscribeFieldResolver\n  });\n}\n/**\n * This function checks if the error is a GraphQLError. If it is, report it as\n * an ExecutionResult, containing only errors and no data. Otherwise treat the\n * error as a system-class error and re-throw it.\n */\n\nfunction reportGraphQLError(error) {\n  if (error instanceof GraphQLError) {\n    return {\n      errors: [error]\n    };\n  }\n\n  throw error;\n}\n\nfunction subscribeImpl(args) {\n  var schema = args.schema,\n      document = args.document,\n      rootValue = args.rootValue,\n      contextValue = args.contextValue,\n      variableValues = args.variableValues,\n      operationName = args.operationName,\n      fieldResolver = args.fieldResolver,\n      subscribeFieldResolver = args.subscribeFieldResolver;\n  var sourcePromise = createSourceEventStream(schema, document, rootValue, contextValue, variableValues, operationName, subscribeFieldResolver); // For each payload yielded from a subscription, map it over the normal\n  // GraphQL `execute` function, with `payload` as the rootValue.\n  // This implements the \"MapSourceToResponseEvent\" algorithm described in\n  // the GraphQL specification. The `execute` function provides the\n  // \"ExecuteSubscriptionEvent\" algorithm, as it is nearly identical to the\n  // \"ExecuteQuery\" algorithm, for which `execute` is also used.\n\n  var mapSourceToResponse = function mapSourceToResponse(payload) {\n    return execute({\n      schema: schema,\n      document: document,\n      rootValue: payload,\n      contextValue: contextValue,\n      variableValues: variableValues,\n      operationName: operationName,\n      fieldResolver: fieldResolver\n    });\n  }; // Resolve the Source Stream, then map every source value to a\n  // ExecutionResult value as described above.\n\n\n  return sourcePromise.then(function (resultOrStream) {\n    return (// Note: Flow can't refine isAsyncIterable, so explicit casts are used.\n      isAsyncIterable(resultOrStream) ? mapAsyncIterator(resultOrStream, mapSourceToResponse, reportGraphQLError) : resultOrStream\n    );\n  });\n}\n/**\n * Implements the \"CreateSourceEventStream\" algorithm described in the\n * GraphQL specification, resolving the subscription source event stream.\n *\n * Returns a Promise which resolves to either an AsyncIterable (if successful)\n * or an ExecutionResult (error). The promise will be rejected if the schema or\n * other arguments to this function are invalid, or if the resolved event stream\n * is not an async iterable.\n *\n * If the client-provided arguments to this function do not result in a\n * compliant subscription, a GraphQL Response (ExecutionResult) with\n * descriptive errors and no data will be returned.\n *\n * If the the source stream could not be created due to faulty subscription\n * resolver logic or underlying systems, the promise will resolve to a single\n * ExecutionResult containing `errors` and no `data`.\n *\n * If the operation succeeded, the promise resolves to the AsyncIterable for the\n * event stream returned by the resolver.\n *\n * A Source Event Stream represents a sequence of events, each of which triggers\n * a GraphQL execution for that event.\n *\n * This may be useful when hosting the stateful subscription service in a\n * different process or machine than the stateless GraphQL execution engine,\n * or otherwise separating these two steps. For more on this, see the\n * \"Supporting Subscriptions at Scale\" information in the GraphQL specification.\n */\n\n\nexport function createSourceEventStream(schema, document, rootValue, contextValue, variableValues, operationName, fieldResolver) {\n  // If arguments are missing or incorrectly typed, this is an internal\n  // developer mistake which should throw an early error.\n  assertValidExecutionArguments(schema, document, variableValues);\n  return new Promise(function (resolve) {\n    // If a valid context cannot be created due to incorrect arguments,\n    // this will throw an error.\n    var exeContext = buildExecutionContext(schema, document, rootValue, contextValue, variableValues, operationName, fieldResolver);\n    resolve( // Return early errors if execution context failed.\n    Array.isArray(exeContext) ? {\n      errors: exeContext\n    } : executeSubscription(exeContext));\n  }).catch(reportGraphQLError);\n}\n\nfunction executeSubscription(exeContext) {\n  var schema = exeContext.schema,\n      operation = exeContext.operation,\n      variableValues = exeContext.variableValues,\n      rootValue = exeContext.rootValue;\n  var type = getOperationRootType(schema, operation);\n  var fields = collectFields(exeContext, type, operation.selectionSet, Object.create(null), Object.create(null));\n  var responseNames = Object.keys(fields);\n  var responseName = responseNames[0];\n  var fieldNodes = fields[responseName];\n  var fieldNode = fieldNodes[0];\n  var fieldName = fieldNode.name.value;\n  var fieldDef = getFieldDef(schema, type, fieldName);\n\n  if (!fieldDef) {\n    throw new GraphQLError(\"The subscription field \\\"\".concat(fieldName, \"\\\" is not defined.\"), fieldNodes);\n  }\n\n  var path = addPath(undefined, responseName, type.name);\n  var info = buildResolveInfo(exeContext, fieldDef, fieldNodes, type, path); // Coerce to Promise for easier error handling and consistent return type.\n\n  return new Promise(function (resolveResult) {\n    var _fieldDef$subscribe;\n\n    // Implements the \"ResolveFieldEventStream\" algorithm from GraphQL specification.\n    // It differs from \"ResolveFieldValue\" due to providing a different `resolveFn`.\n    // Build a JS object of arguments from the field.arguments AST, using the\n    // variables scope to fulfill any variable references.\n    var args = getArgumentValues(fieldDef, fieldNodes[0], variableValues); // The resolve function's optional third argument is a context value that\n    // is provided to every resolve function within an execution. It is commonly\n    // used to represent an authenticated user, or request-specific caches.\n\n    var contextValue = exeContext.contextValue; // Call the `subscribe()` resolver or the default resolver to produce an\n    // AsyncIterable yielding raw payloads.\n\n    var resolveFn = (_fieldDef$subscribe = fieldDef.subscribe) !== null && _fieldDef$subscribe !== void 0 ? _fieldDef$subscribe : exeContext.fieldResolver;\n    resolveResult(resolveFn(rootValue, args, contextValue, info));\n  }).then(function (eventStream) {\n    if (eventStream instanceof Error) {\n      throw locatedError(eventStream, fieldNodes, pathToArray(path));\n    } // Assert field returned an event stream, otherwise yield an error.\n\n\n    if (!isAsyncIterable(eventStream)) {\n      throw new Error('Subscription field must return Async Iterable. ' + \"Received: \".concat(inspect(eventStream), \".\"));\n    }\n\n    return eventStream;\n  }, function (error) {\n    throw locatedError(error, fieldNodes, pathToArray(path));\n  });\n}\n","import { GraphQLError } from \"../../../error/GraphQLError.mjs\";\nimport { getNamedType } from \"../../../type/definition.mjs\";\nimport { isIntrospectionType } from \"../../../type/introspection.mjs\";\n\n/**\n * Prohibit introspection queries\n *\n * A GraphQL document is only valid if all fields selected are not fields that\n * return an introspection type.\n *\n * Note: This rule is optional and is not part of the Validation section of the\n * GraphQL Specification. This rule effectively disables introspection, which\n * does not reflect best practices and should only be done if absolutely necessary.\n */\nexport function NoSchemaIntrospectionCustomRule(context) {\n  return {\n    Field: function Field(node) {\n      var type = getNamedType(context.getType());\n\n      if (type && isIntrospectionType(type)) {\n        context.reportError(new GraphQLError(\"GraphQL introspection has been disabled, but the requested query contained the field \\\"\".concat(node.name.value, \"\\\".\"), node));\n      }\n    }\n  };\n}\n","import devAssert from \"../jsutils/devAssert.mjs\";\n\n/**\n * Given a GraphQLError, format it according to the rules described by the\n * Response Format, Errors section of the GraphQL Specification.\n */\nexport function formatError(error) {\n  var _error$message;\n\n  error || devAssert(0, 'Received null or undefined error.');\n  var message = (_error$message = error.message) !== null && _error$message !== void 0 ? _error$message : 'An unknown error occurred.';\n  var locations = error.locations;\n  var path = error.path;\n  var extensions = error.extensions;\n  return extensions && Object.keys(extensions).length > 0 ? {\n    message: message,\n    locations: locations,\n    path: path,\n    extensions: extensions\n  } : {\n    message: message,\n    locations: locations,\n    path: path\n  };\n}\n/**\n * @see https://github.com/graphql/graphql-spec/blob/master/spec/Section%207%20--%20Response.md#errors\n */\n","import { Kind } from \"../language/kinds.mjs\";\n/**\n * Returns an operation AST given a document AST and optionally an operation\n * name. If a name is not provided, an operation is only returned if only one is\n * provided in the document.\n */\n\nexport function getOperationAST(documentAST, operationName) {\n  var operation = null;\n\n  for (var _i2 = 0, _documentAST$definiti2 = documentAST.definitions; _i2 < _documentAST$definiti2.length; _i2++) {\n    var definition = _documentAST$definiti2[_i2];\n\n    if (definition.kind === Kind.OPERATION_DEFINITION) {\n      var _definition$name;\n\n      if (operationName == null) {\n        // If no operation name was provided, only return an Operation if there\n        // is one defined in the document. Upon encountering the second, return\n        // null.\n        if (operation) {\n          return null;\n        }\n\n        operation = definition;\n      } else if (((_definition$name = definition.name) === null || _definition$name === void 0 ? void 0 : _definition$name.value) === operationName) {\n        return definition;\n      }\n    }\n  }\n\n  return operation;\n}\n","function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport invariant from \"../jsutils/invariant.mjs\";\nimport { parse } from \"../language/parser.mjs\";\nimport { executeSync } from \"../execution/execute.mjs\";\nimport { getIntrospectionQuery } from \"./getIntrospectionQuery.mjs\";\n/**\n * Build an IntrospectionQuery from a GraphQLSchema\n *\n * IntrospectionQuery is useful for utilities that care about type and field\n * relationships, but do not need to traverse through those relationships.\n *\n * This is the inverse of buildClientSchema. The primary use case is outside\n * of the server context, for instance when doing schema comparisons.\n */\n\nexport function introspectionFromSchema(schema, options) {\n  var optionsWithDefaults = _objectSpread({\n    specifiedByUrl: true,\n    directiveIsRepeatable: true,\n    schemaDescription: true,\n    inputValueDeprecation: true\n  }, options);\n\n  var document = parse(getIntrospectionQuery(optionsWithDefaults));\n  var result = executeSync({\n    schema: schema,\n    document: document\n  });\n  !result.errors && result.data || invariant(0);\n  return result.data;\n}\n","function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport objectValues from \"../polyfills/objectValues.mjs\";\nimport keyMap from \"../jsutils/keyMap.mjs\";\nimport inspect from \"../jsutils/inspect.mjs\";\nimport mapValue from \"../jsutils/mapValue.mjs\";\nimport invariant from \"../jsutils/invariant.mjs\";\nimport devAssert from \"../jsutils/devAssert.mjs\";\nimport { Kind } from \"../language/kinds.mjs\";\nimport { TokenKind } from \"../language/tokenKind.mjs\";\nimport { dedentBlockStringValue } from \"../language/blockString.mjs\";\nimport { isTypeDefinitionNode, isTypeExtensionNode } from \"../language/predicates.mjs\";\nimport { assertValidSDLExtension } from \"../validation/validate.mjs\";\nimport { getDirectiveValues } from \"../execution/values.mjs\";\nimport { assertSchema, GraphQLSchema } from \"../type/schema.mjs\";\nimport { specifiedScalarTypes, isSpecifiedScalarType } from \"../type/scalars.mjs\";\nimport { introspectionTypes, isIntrospectionType } from \"../type/introspection.mjs\";\nimport { GraphQLDirective, GraphQLDeprecatedDirective, GraphQLSpecifiedByDirective } from \"../type/directives.mjs\";\nimport { isScalarType, isObjectType, isInterfaceType, isUnionType, isListType, isNonNullType, isEnumType, isInputObjectType, GraphQLList, GraphQLNonNull, GraphQLScalarType, GraphQLObjectType, GraphQLInterfaceType, GraphQLUnionType, GraphQLEnumType, GraphQLInputObjectType } from \"../type/definition.mjs\";\nimport { valueFromAST } from \"./valueFromAST.mjs\";\n\n/**\n * Produces a new schema given an existing schema and a document which may\n * contain GraphQL type extensions and definitions. The original schema will\n * remain unaltered.\n *\n * Because a schema represents a graph of references, a schema cannot be\n * extended without effectively making an entire copy. We do not know until it's\n * too late if subgraphs remain unchanged.\n *\n * This algorithm copies the provided schema, applying extensions while\n * producing the copy. The original schema remains unaltered.\n *\n * Accepts options as a third argument:\n *\n *    - commentDescriptions:\n *        Provide true to use preceding comments as the description.\n *\n */\nexport function extendSchema(schema, documentAST, options) {\n  assertSchema(schema);\n  documentAST != null && documentAST.kind === Kind.DOCUMENT || devAssert(0, 'Must provide valid Document AST.');\n\n  if ((options === null || options === void 0 ? void 0 : options.assumeValid) !== true && (options === null || options === void 0 ? void 0 : options.assumeValidSDL) !== true) {\n    assertValidSDLExtension(documentAST, schema);\n  }\n\n  var schemaConfig = schema.toConfig();\n  var extendedConfig = extendSchemaImpl(schemaConfig, documentAST, options);\n  return schemaConfig === extendedConfig ? schema : new GraphQLSchema(extendedConfig);\n}\n/**\n * @internal\n */\n\nexport function extendSchemaImpl(schemaConfig, documentAST, options) {\n  var _schemaDef, _schemaDef$descriptio, _schemaDef2, _options$assumeValid;\n\n  // Collect the type definitions and extensions found in the document.\n  var typeDefs = [];\n  var typeExtensionsMap = Object.create(null); // New directives and types are separate because a directives and types can\n  // have the same name. For example, a type named \"skip\".\n\n  var directiveDefs = [];\n  var schemaDef; // Schema extensions are collected which may add additional operation types.\n\n  var schemaExtensions = [];\n\n  for (var _i2 = 0, _documentAST$definiti2 = documentAST.definitions; _i2 < _documentAST$definiti2.length; _i2++) {\n    var def = _documentAST$definiti2[_i2];\n\n    if (def.kind === Kind.SCHEMA_DEFINITION) {\n      schemaDef = def;\n    } else if (def.kind === Kind.SCHEMA_EXTENSION) {\n      schemaExtensions.push(def);\n    } else if (isTypeDefinitionNode(def)) {\n      typeDefs.push(def);\n    } else if (isTypeExtensionNode(def)) {\n      var extendedTypeName = def.name.value;\n      var existingTypeExtensions = typeExtensionsMap[extendedTypeName];\n      typeExtensionsMap[extendedTypeName] = existingTypeExtensions ? existingTypeExtensions.concat([def]) : [def];\n    } else if (def.kind === Kind.DIRECTIVE_DEFINITION) {\n      directiveDefs.push(def);\n    }\n  } // If this document contains no new types, extensions, or directives then\n  // return the same unmodified GraphQLSchema instance.\n\n\n  if (Object.keys(typeExtensionsMap).length === 0 && typeDefs.length === 0 && directiveDefs.length === 0 && schemaExtensions.length === 0 && schemaDef == null) {\n    return schemaConfig;\n  }\n\n  var typeMap = Object.create(null);\n\n  for (var _i4 = 0, _schemaConfig$types2 = schemaConfig.types; _i4 < _schemaConfig$types2.length; _i4++) {\n    var existingType = _schemaConfig$types2[_i4];\n    typeMap[existingType.name] = extendNamedType(existingType);\n  }\n\n  for (var _i6 = 0; _i6 < typeDefs.length; _i6++) {\n    var _stdTypeMap$name;\n\n    var typeNode = typeDefs[_i6];\n    var name = typeNode.name.value;\n    typeMap[name] = (_stdTypeMap$name = stdTypeMap[name]) !== null && _stdTypeMap$name !== void 0 ? _stdTypeMap$name : buildType(typeNode);\n  }\n\n  var operationTypes = _objectSpread(_objectSpread({\n    // Get the extended root operation types.\n    query: schemaConfig.query && replaceNamedType(schemaConfig.query),\n    mutation: schemaConfig.mutation && replaceNamedType(schemaConfig.mutation),\n    subscription: schemaConfig.subscription && replaceNamedType(schemaConfig.subscription)\n  }, schemaDef && getOperationTypes([schemaDef])), getOperationTypes(schemaExtensions)); // Then produce and return a Schema config with these types.\n\n\n  return _objectSpread(_objectSpread({\n    description: (_schemaDef = schemaDef) === null || _schemaDef === void 0 ? void 0 : (_schemaDef$descriptio = _schemaDef.description) === null || _schemaDef$descriptio === void 0 ? void 0 : _schemaDef$descriptio.value\n  }, operationTypes), {}, {\n    types: objectValues(typeMap),\n    directives: [].concat(schemaConfig.directives.map(replaceDirective), directiveDefs.map(buildDirective)),\n    extensions: undefined,\n    astNode: (_schemaDef2 = schemaDef) !== null && _schemaDef2 !== void 0 ? _schemaDef2 : schemaConfig.astNode,\n    extensionASTNodes: schemaConfig.extensionASTNodes.concat(schemaExtensions),\n    assumeValid: (_options$assumeValid = options === null || options === void 0 ? void 0 : options.assumeValid) !== null && _options$assumeValid !== void 0 ? _options$assumeValid : false\n  }); // Below are functions used for producing this schema that have closed over\n  // this scope and have access to the schema, cache, and newly defined types.\n\n  function replaceType(type) {\n    if (isListType(type)) {\n      // $FlowFixMe[incompatible-return]\n      return new GraphQLList(replaceType(type.ofType));\n    }\n\n    if (isNonNullType(type)) {\n      // $FlowFixMe[incompatible-return]\n      return new GraphQLNonNull(replaceType(type.ofType));\n    }\n\n    return replaceNamedType(type);\n  }\n\n  function replaceNamedType(type) {\n    // Note: While this could make early assertions to get the correctly\n    // typed values, that would throw immediately while type system\n    // validation with validateSchema() will produce more actionable results.\n    return typeMap[type.name];\n  }\n\n  function replaceDirective(directive) {\n    var config = directive.toConfig();\n    return new GraphQLDirective(_objectSpread(_objectSpread({}, config), {}, {\n      args: mapValue(config.args, extendArg)\n    }));\n  }\n\n  function extendNamedType(type) {\n    if (isIntrospectionType(type) || isSpecifiedScalarType(type)) {\n      // Builtin types are not extended.\n      return type;\n    }\n\n    if (isScalarType(type)) {\n      return extendScalarType(type);\n    }\n\n    if (isObjectType(type)) {\n      return extendObjectType(type);\n    }\n\n    if (isInterfaceType(type)) {\n      return extendInterfaceType(type);\n    }\n\n    if (isUnionType(type)) {\n      return extendUnionType(type);\n    }\n\n    if (isEnumType(type)) {\n      return extendEnumType(type);\n    } // istanbul ignore else (See: 'https://github.com/graphql/graphql-js/issues/2618')\n\n\n    if (isInputObjectType(type)) {\n      return extendInputObjectType(type);\n    } // istanbul ignore next (Not reachable. All possible types have been considered)\n\n\n    false || invariant(0, 'Unexpected type: ' + inspect(type));\n  }\n\n  function extendInputObjectType(type) {\n    var _typeExtensionsMap$co;\n\n    var config = type.toConfig();\n    var extensions = (_typeExtensionsMap$co = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co !== void 0 ? _typeExtensionsMap$co : [];\n    return new GraphQLInputObjectType(_objectSpread(_objectSpread({}, config), {}, {\n      fields: function fields() {\n        return _objectSpread(_objectSpread({}, mapValue(config.fields, function (field) {\n          return _objectSpread(_objectSpread({}, field), {}, {\n            type: replaceType(field.type)\n          });\n        })), buildInputFieldMap(extensions));\n      },\n      extensionASTNodes: config.extensionASTNodes.concat(extensions)\n    }));\n  }\n\n  function extendEnumType(type) {\n    var _typeExtensionsMap$ty;\n\n    var config = type.toConfig();\n    var extensions = (_typeExtensionsMap$ty = typeExtensionsMap[type.name]) !== null && _typeExtensionsMap$ty !== void 0 ? _typeExtensionsMap$ty : [];\n    return new GraphQLEnumType(_objectSpread(_objectSpread({}, config), {}, {\n      values: _objectSpread(_objectSpread({}, config.values), buildEnumValueMap(extensions)),\n      extensionASTNodes: config.extensionASTNodes.concat(extensions)\n    }));\n  }\n\n  function extendScalarType(type) {\n    var _typeExtensionsMap$co2;\n\n    var config = type.toConfig();\n    var extensions = (_typeExtensionsMap$co2 = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co2 !== void 0 ? _typeExtensionsMap$co2 : [];\n    var specifiedByUrl = config.specifiedByUrl;\n\n    for (var _i8 = 0; _i8 < extensions.length; _i8++) {\n      var _getSpecifiedByUrl;\n\n      var extensionNode = extensions[_i8];\n      specifiedByUrl = (_getSpecifiedByUrl = getSpecifiedByUrl(extensionNode)) !== null && _getSpecifiedByUrl !== void 0 ? _getSpecifiedByUrl : specifiedByUrl;\n    }\n\n    return new GraphQLScalarType(_objectSpread(_objectSpread({}, config), {}, {\n      specifiedByUrl: specifiedByUrl,\n      extensionASTNodes: config.extensionASTNodes.concat(extensions)\n    }));\n  }\n\n  function extendObjectType(type) {\n    var _typeExtensionsMap$co3;\n\n    var config = type.toConfig();\n    var extensions = (_typeExtensionsMap$co3 = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co3 !== void 0 ? _typeExtensionsMap$co3 : [];\n    return new GraphQLObjectType(_objectSpread(_objectSpread({}, config), {}, {\n      interfaces: function interfaces() {\n        return [].concat(type.getInterfaces().map(replaceNamedType), buildInterfaces(extensions));\n      },\n      fields: function fields() {\n        return _objectSpread(_objectSpread({}, mapValue(config.fields, extendField)), buildFieldMap(extensions));\n      },\n      extensionASTNodes: config.extensionASTNodes.concat(extensions)\n    }));\n  }\n\n  function extendInterfaceType(type) {\n    var _typeExtensionsMap$co4;\n\n    var config = type.toConfig();\n    var extensions = (_typeExtensionsMap$co4 = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co4 !== void 0 ? _typeExtensionsMap$co4 : [];\n    return new GraphQLInterfaceType(_objectSpread(_objectSpread({}, config), {}, {\n      interfaces: function interfaces() {\n        return [].concat(type.getInterfaces().map(replaceNamedType), buildInterfaces(extensions));\n      },\n      fields: function fields() {\n        return _objectSpread(_objectSpread({}, mapValue(config.fields, extendField)), buildFieldMap(extensions));\n      },\n      extensionASTNodes: config.extensionASTNodes.concat(extensions)\n    }));\n  }\n\n  function extendUnionType(type) {\n    var _typeExtensionsMap$co5;\n\n    var config = type.toConfig();\n    var extensions = (_typeExtensionsMap$co5 = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co5 !== void 0 ? _typeExtensionsMap$co5 : [];\n    return new GraphQLUnionType(_objectSpread(_objectSpread({}, config), {}, {\n      types: function types() {\n        return [].concat(type.getTypes().map(replaceNamedType), buildUnionTypes(extensions));\n      },\n      extensionASTNodes: config.extensionASTNodes.concat(extensions)\n    }));\n  }\n\n  function extendField(field) {\n    return _objectSpread(_objectSpread({}, field), {}, {\n      type: replaceType(field.type),\n      // $FlowFixMe[incompatible-call]\n      args: mapValue(field.args, extendArg)\n    });\n  }\n\n  function extendArg(arg) {\n    return _objectSpread(_objectSpread({}, arg), {}, {\n      type: replaceType(arg.type)\n    });\n  }\n\n  function getOperationTypes(nodes) {\n    var opTypes = {};\n\n    for (var _i10 = 0; _i10 < nodes.length; _i10++) {\n      var _node$operationTypes;\n\n      var node = nodes[_i10];\n      // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')\n      var operationTypesNodes = (_node$operationTypes = node.operationTypes) !== null && _node$operationTypes !== void 0 ? _node$operationTypes : [];\n\n      for (var _i12 = 0; _i12 < operationTypesNodes.length; _i12++) {\n        var operationType = operationTypesNodes[_i12];\n        opTypes[operationType.operation] = getNamedType(operationType.type);\n      }\n    } // Note: While this could make early assertions to get the correctly\n    // typed values below, that would throw immediately while type system\n    // validation with validateSchema() will produce more actionable results.\n\n\n    return opTypes;\n  }\n\n  function getNamedType(node) {\n    var _stdTypeMap$name2;\n\n    var name = node.name.value;\n    var type = (_stdTypeMap$name2 = stdTypeMap[name]) !== null && _stdTypeMap$name2 !== void 0 ? _stdTypeMap$name2 : typeMap[name];\n\n    if (type === undefined) {\n      throw new Error(\"Unknown type: \\\"\".concat(name, \"\\\".\"));\n    }\n\n    return type;\n  }\n\n  function getWrappedType(node) {\n    if (node.kind === Kind.LIST_TYPE) {\n      return new GraphQLList(getWrappedType(node.type));\n    }\n\n    if (node.kind === Kind.NON_NULL_TYPE) {\n      return new GraphQLNonNull(getWrappedType(node.type));\n    }\n\n    return getNamedType(node);\n  }\n\n  function buildDirective(node) {\n    var locations = node.locations.map(function (_ref) {\n      var value = _ref.value;\n      return value;\n    });\n    return new GraphQLDirective({\n      name: node.name.value,\n      description: getDescription(node, options),\n      locations: locations,\n      isRepeatable: node.repeatable,\n      args: buildArgumentMap(node.arguments),\n      astNode: node\n    });\n  }\n\n  function buildFieldMap(nodes) {\n    var fieldConfigMap = Object.create(null);\n\n    for (var _i14 = 0; _i14 < nodes.length; _i14++) {\n      var _node$fields;\n\n      var node = nodes[_i14];\n      // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')\n      var nodeFields = (_node$fields = node.fields) !== null && _node$fields !== void 0 ? _node$fields : [];\n\n      for (var _i16 = 0; _i16 < nodeFields.length; _i16++) {\n        var field = nodeFields[_i16];\n        fieldConfigMap[field.name.value] = {\n          // Note: While this could make assertions to get the correctly typed\n          // value, that would throw immediately while type system validation\n          // with validateSchema() will produce more actionable results.\n          type: getWrappedType(field.type),\n          description: getDescription(field, options),\n          args: buildArgumentMap(field.arguments),\n          deprecationReason: getDeprecationReason(field),\n          astNode: field\n        };\n      }\n    }\n\n    return fieldConfigMap;\n  }\n\n  function buildArgumentMap(args) {\n    // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')\n    var argsNodes = args !== null && args !== void 0 ? args : [];\n    var argConfigMap = Object.create(null);\n\n    for (var _i18 = 0; _i18 < argsNodes.length; _i18++) {\n      var arg = argsNodes[_i18];\n      // Note: While this could make assertions to get the correctly typed\n      // value, that would throw immediately while type system validation\n      // with validateSchema() will produce more actionable results.\n      var type = getWrappedType(arg.type);\n      argConfigMap[arg.name.value] = {\n        type: type,\n        description: getDescription(arg, options),\n        defaultValue: valueFromAST(arg.defaultValue, type),\n        deprecationReason: getDeprecationReason(arg),\n        astNode: arg\n      };\n    }\n\n    return argConfigMap;\n  }\n\n  function buildInputFieldMap(nodes) {\n    var inputFieldMap = Object.create(null);\n\n    for (var _i20 = 0; _i20 < nodes.length; _i20++) {\n      var _node$fields2;\n\n      var node = nodes[_i20];\n      // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')\n      var fieldsNodes = (_node$fields2 = node.fields) !== null && _node$fields2 !== void 0 ? _node$fields2 : [];\n\n      for (var _i22 = 0; _i22 < fieldsNodes.length; _i22++) {\n        var field = fieldsNodes[_i22];\n        // Note: While this could make assertions to get the correctly typed\n        // value, that would throw immediately while type system validation\n        // with validateSchema() will produce more actionable results.\n        var type = getWrappedType(field.type);\n        inputFieldMap[field.name.value] = {\n          type: type,\n          description: getDescription(field, options),\n          defaultValue: valueFromAST(field.defaultValue, type),\n          deprecationReason: getDeprecationReason(field),\n          astNode: field\n        };\n      }\n    }\n\n    return inputFieldMap;\n  }\n\n  function buildEnumValueMap(nodes) {\n    var enumValueMap = Object.create(null);\n\n    for (var _i24 = 0; _i24 < nodes.length; _i24++) {\n      var _node$values;\n\n      var node = nodes[_i24];\n      // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')\n      var valuesNodes = (_node$values = node.values) !== null && _node$values !== void 0 ? _node$values : [];\n\n      for (var _i26 = 0; _i26 < valuesNodes.length; _i26++) {\n        var value = valuesNodes[_i26];\n        enumValueMap[value.name.value] = {\n          description: getDescription(value, options),\n          deprecationReason: getDeprecationReason(value),\n          astNode: value\n        };\n      }\n    }\n\n    return enumValueMap;\n  }\n\n  function buildInterfaces(nodes) {\n    var interfaces = [];\n\n    for (var _i28 = 0; _i28 < nodes.length; _i28++) {\n      var _node$interfaces;\n\n      var node = nodes[_i28];\n      // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')\n      var interfacesNodes = (_node$interfaces = node.interfaces) !== null && _node$interfaces !== void 0 ? _node$interfaces : [];\n\n      for (var _i30 = 0; _i30 < interfacesNodes.length; _i30++) {\n        var type = interfacesNodes[_i30];\n        // Note: While this could make assertions to get the correctly typed\n        // values below, that would throw immediately while type system\n        // validation with validateSchema() will produce more actionable\n        // results.\n        interfaces.push(getNamedType(type));\n      }\n    }\n\n    return interfaces;\n  }\n\n  function buildUnionTypes(nodes) {\n    var types = [];\n\n    for (var _i32 = 0; _i32 < nodes.length; _i32++) {\n      var _node$types;\n\n      var node = nodes[_i32];\n      // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')\n      var typeNodes = (_node$types = node.types) !== null && _node$types !== void 0 ? _node$types : [];\n\n      for (var _i34 = 0; _i34 < typeNodes.length; _i34++) {\n        var type = typeNodes[_i34];\n        // Note: While this could make assertions to get the correctly typed\n        // values below, that would throw immediately while type system\n        // validation with validateSchema() will produce more actionable\n        // results.\n        types.push(getNamedType(type));\n      }\n    }\n\n    return types;\n  }\n\n  function buildType(astNode) {\n    var _typeExtensionsMap$na;\n\n    var name = astNode.name.value;\n    var description = getDescription(astNode, options);\n    var extensionNodes = (_typeExtensionsMap$na = typeExtensionsMap[name]) !== null && _typeExtensionsMap$na !== void 0 ? _typeExtensionsMap$na : [];\n\n    switch (astNode.kind) {\n      case Kind.OBJECT_TYPE_DEFINITION:\n        {\n          var extensionASTNodes = extensionNodes;\n          var allNodes = [astNode].concat(extensionASTNodes);\n          return new GraphQLObjectType({\n            name: name,\n            description: description,\n            interfaces: function interfaces() {\n              return buildInterfaces(allNodes);\n            },\n            fields: function fields() {\n              return buildFieldMap(allNodes);\n            },\n            astNode: astNode,\n            extensionASTNodes: extensionASTNodes\n          });\n        }\n\n      case Kind.INTERFACE_TYPE_DEFINITION:\n        {\n          var _extensionASTNodes = extensionNodes;\n\n          var _allNodes = [astNode].concat(_extensionASTNodes);\n\n          return new GraphQLInterfaceType({\n            name: name,\n            description: description,\n            interfaces: function interfaces() {\n              return buildInterfaces(_allNodes);\n            },\n            fields: function fields() {\n              return buildFieldMap(_allNodes);\n            },\n            astNode: astNode,\n            extensionASTNodes: _extensionASTNodes\n          });\n        }\n\n      case Kind.ENUM_TYPE_DEFINITION:\n        {\n          var _extensionASTNodes2 = extensionNodes;\n\n          var _allNodes2 = [astNode].concat(_extensionASTNodes2);\n\n          return new GraphQLEnumType({\n            name: name,\n            description: description,\n            values: buildEnumValueMap(_allNodes2),\n            astNode: astNode,\n            extensionASTNodes: _extensionASTNodes2\n          });\n        }\n\n      case Kind.UNION_TYPE_DEFINITION:\n        {\n          var _extensionASTNodes3 = extensionNodes;\n\n          var _allNodes3 = [astNode].concat(_extensionASTNodes3);\n\n          return new GraphQLUnionType({\n            name: name,\n            description: description,\n            types: function types() {\n              return buildUnionTypes(_allNodes3);\n            },\n            astNode: astNode,\n            extensionASTNodes: _extensionASTNodes3\n          });\n        }\n\n      case Kind.SCALAR_TYPE_DEFINITION:\n        {\n          var _extensionASTNodes4 = extensionNodes;\n          return new GraphQLScalarType({\n            name: name,\n            description: description,\n            specifiedByUrl: getSpecifiedByUrl(astNode),\n            astNode: astNode,\n            extensionASTNodes: _extensionASTNodes4\n          });\n        }\n\n      case Kind.INPUT_OBJECT_TYPE_DEFINITION:\n        {\n          var _extensionASTNodes5 = extensionNodes;\n\n          var _allNodes4 = [astNode].concat(_extensionASTNodes5);\n\n          return new GraphQLInputObjectType({\n            name: name,\n            description: description,\n            fields: function fields() {\n              return buildInputFieldMap(_allNodes4);\n            },\n            astNode: astNode,\n            extensionASTNodes: _extensionASTNodes5\n          });\n        }\n    } // istanbul ignore next (Not reachable. All possible type definition nodes have been considered)\n\n\n    false || invariant(0, 'Unexpected type definition node: ' + inspect(astNode));\n  }\n}\nvar stdTypeMap = keyMap(specifiedScalarTypes.concat(introspectionTypes), function (type) {\n  return type.name;\n});\n/**\n * Given a field or enum value node, returns the string value for the\n * deprecation reason.\n */\n\nfunction getDeprecationReason(node) {\n  var deprecated = getDirectiveValues(GraphQLDeprecatedDirective, node);\n  return deprecated === null || deprecated === void 0 ? void 0 : deprecated.reason;\n}\n/**\n * Given a scalar node, returns the string value for the specifiedByUrl.\n */\n\n\nfunction getSpecifiedByUrl(node) {\n  var specifiedBy = getDirectiveValues(GraphQLSpecifiedByDirective, node);\n  return specifiedBy === null || specifiedBy === void 0 ? void 0 : specifiedBy.url;\n}\n/**\n * Given an ast node, returns its string description.\n * @deprecated: provided to ease adoption and will be removed in v16.\n *\n * Accepts options as a second argument:\n *\n *    - commentDescriptions:\n *        Provide true to use preceding comments as the description.\n *\n */\n\n\nexport function getDescription(node, options) {\n  if (node.description) {\n    return node.description.value;\n  }\n\n  if ((options === null || options === void 0 ? void 0 : options.commentDescriptions) === true) {\n    var rawValue = getLeadingCommentBlock(node);\n\n    if (rawValue !== undefined) {\n      return dedentBlockStringValue('\\n' + rawValue);\n    }\n  }\n}\n\nfunction getLeadingCommentBlock(node) {\n  var loc = node.loc;\n\n  if (!loc) {\n    return;\n  }\n\n  var comments = [];\n  var token = loc.startToken.prev;\n\n  while (token != null && token.kind === TokenKind.COMMENT && token.next && token.prev && token.line + 1 === token.next.line && token.line !== token.prev.line) {\n    var value = String(token.value);\n    comments.push(value);\n    token = token.prev;\n  }\n\n  return comments.length > 0 ? comments.reverse().join('\\n') : undefined;\n}\n","import devAssert from \"../jsutils/devAssert.mjs\";\nimport { Kind } from \"../language/kinds.mjs\";\nimport { parse } from \"../language/parser.mjs\";\nimport { assertValidSDL } from \"../validation/validate.mjs\";\nimport { GraphQLSchema } from \"../type/schema.mjs\";\nimport { specifiedDirectives } from \"../type/directives.mjs\";\nimport { extendSchemaImpl } from \"./extendSchema.mjs\";\n\n/**\n * This takes the ast of a schema document produced by the parse function in\n * src/language/parser.js.\n *\n * If no schema definition is provided, then it will look for types named Query\n * and Mutation.\n *\n * Given that AST it constructs a GraphQLSchema. The resulting schema\n * has no resolve methods, so execution will use default resolvers.\n *\n * Accepts options as a second argument:\n *\n *    - commentDescriptions:\n *        Provide true to use preceding comments as the description.\n *\n */\nexport function buildASTSchema(documentAST, options) {\n  documentAST != null && documentAST.kind === Kind.DOCUMENT || devAssert(0, 'Must provide valid Document AST.');\n\n  if ((options === null || options === void 0 ? void 0 : options.assumeValid) !== true && (options === null || options === void 0 ? void 0 : options.assumeValidSDL) !== true) {\n    assertValidSDL(documentAST);\n  }\n\n  var emptySchemaConfig = {\n    description: undefined,\n    types: [],\n    directives: [],\n    extensions: undefined,\n    extensionASTNodes: [],\n    assumeValid: false\n  };\n  var config = extendSchemaImpl(emptySchemaConfig, documentAST, options);\n\n  if (config.astNode == null) {\n    for (var _i2 = 0, _config$types2 = config.types; _i2 < _config$types2.length; _i2++) {\n      var type = _config$types2[_i2];\n\n      switch (type.name) {\n        // Note: While this could make early assertions to get the correctly\n        // typed values below, that would throw immediately while type system\n        // validation with validateSchema() will produce more actionable results.\n        case 'Query':\n          config.query = type;\n          break;\n\n        case 'Mutation':\n          config.mutation = type;\n          break;\n\n        case 'Subscription':\n          config.subscription = type;\n          break;\n      }\n    }\n  }\n\n  var directives = config.directives; // If specified directives were not explicitly declared, add them.\n\n  var _loop = function _loop(_i4) {\n    var stdDirective = specifiedDirectives[_i4];\n\n    if (directives.every(function (directive) {\n      return directive.name !== stdDirective.name;\n    })) {\n      directives.push(stdDirective);\n    }\n  };\n\n  for (var _i4 = 0; _i4 < specifiedDirectives.length; _i4++) {\n    _loop(_i4);\n  }\n\n  return new GraphQLSchema(config);\n}\n/**\n * A helper function to build a GraphQLSchema directly from a source\n * document.\n */\n\nexport function buildSchema(source, options) {\n  var document = parse(source, {\n    noLocation: options === null || options === void 0 ? void 0 : options.noLocation,\n    allowLegacySDLEmptyFields: options === null || options === void 0 ? void 0 : options.allowLegacySDLEmptyFields,\n    allowLegacySDLImplementsInterfaces: options === null || options === void 0 ? void 0 : options.allowLegacySDLImplementsInterfaces,\n    experimentalFragmentVariables: options === null || options === void 0 ? void 0 : options.experimentalFragmentVariables\n  });\n  return buildASTSchema(document, {\n    commentDescriptions: options === null || options === void 0 ? void 0 : options.commentDescriptions,\n    assumeValidSDL: options === null || options === void 0 ? void 0 : options.assumeValidSDL,\n    assumeValid: options === null || options === void 0 ? void 0 : options.assumeValid\n  });\n}\n","function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport objectValues from \"../polyfills/objectValues.mjs\";\nimport inspect from \"../jsutils/inspect.mjs\";\nimport invariant from \"../jsutils/invariant.mjs\";\nimport keyValMap from \"../jsutils/keyValMap.mjs\";\nimport naturalCompare from \"../jsutils/naturalCompare.mjs\";\nimport { GraphQLSchema } from \"../type/schema.mjs\";\nimport { GraphQLDirective } from \"../type/directives.mjs\";\nimport { isIntrospectionType } from \"../type/introspection.mjs\";\nimport { GraphQLList, GraphQLNonNull, GraphQLObjectType, GraphQLInterfaceType, GraphQLUnionType, GraphQLEnumType, GraphQLInputObjectType, isListType, isNonNullType, isScalarType, isObjectType, isInterfaceType, isUnionType, isEnumType, isInputObjectType } from \"../type/definition.mjs\";\n/**\n * Sort GraphQLSchema.\n *\n * This function returns a sorted copy of the given GraphQLSchema.\n */\n\nexport function lexicographicSortSchema(schema) {\n  var schemaConfig = schema.toConfig();\n  var typeMap = keyValMap(sortByName(schemaConfig.types), function (type) {\n    return type.name;\n  }, sortNamedType);\n  return new GraphQLSchema(_objectSpread(_objectSpread({}, schemaConfig), {}, {\n    types: objectValues(typeMap),\n    directives: sortByName(schemaConfig.directives).map(sortDirective),\n    query: replaceMaybeType(schemaConfig.query),\n    mutation: replaceMaybeType(schemaConfig.mutation),\n    subscription: replaceMaybeType(schemaConfig.subscription)\n  }));\n\n  function replaceType(type) {\n    if (isListType(type)) {\n      // $FlowFixMe[incompatible-return]\n      return new GraphQLList(replaceType(type.ofType));\n    } else if (isNonNullType(type)) {\n      // $FlowFixMe[incompatible-return]\n      return new GraphQLNonNull(replaceType(type.ofType));\n    }\n\n    return replaceNamedType(type);\n  }\n\n  function replaceNamedType(type) {\n    return typeMap[type.name];\n  }\n\n  function replaceMaybeType(maybeType) {\n    return maybeType && replaceNamedType(maybeType);\n  }\n\n  function sortDirective(directive) {\n    var config = directive.toConfig();\n    return new GraphQLDirective(_objectSpread(_objectSpread({}, config), {}, {\n      locations: sortBy(config.locations, function (x) {\n        return x;\n      }),\n      args: sortArgs(config.args)\n    }));\n  }\n\n  function sortArgs(args) {\n    return sortObjMap(args, function (arg) {\n      return _objectSpread(_objectSpread({}, arg), {}, {\n        type: replaceType(arg.type)\n      });\n    });\n  }\n\n  function sortFields(fieldsMap) {\n    return sortObjMap(fieldsMap, function (field) {\n      return _objectSpread(_objectSpread({}, field), {}, {\n        type: replaceType(field.type),\n        args: sortArgs(field.args)\n      });\n    });\n  }\n\n  function sortInputFields(fieldsMap) {\n    return sortObjMap(fieldsMap, function (field) {\n      return _objectSpread(_objectSpread({}, field), {}, {\n        type: replaceType(field.type)\n      });\n    });\n  }\n\n  function sortTypes(arr) {\n    return sortByName(arr).map(replaceNamedType);\n  }\n\n  function sortNamedType(type) {\n    if (isScalarType(type) || isIntrospectionType(type)) {\n      return type;\n    }\n\n    if (isObjectType(type)) {\n      var config = type.toConfig();\n      return new GraphQLObjectType(_objectSpread(_objectSpread({}, config), {}, {\n        interfaces: function interfaces() {\n          return sortTypes(config.interfaces);\n        },\n        fields: function fields() {\n          return sortFields(config.fields);\n        }\n      }));\n    }\n\n    if (isInterfaceType(type)) {\n      var _config = type.toConfig();\n\n      return new GraphQLInterfaceType(_objectSpread(_objectSpread({}, _config), {}, {\n        interfaces: function interfaces() {\n          return sortTypes(_config.interfaces);\n        },\n        fields: function fields() {\n          return sortFields(_config.fields);\n        }\n      }));\n    }\n\n    if (isUnionType(type)) {\n      var _config2 = type.toConfig();\n\n      return new GraphQLUnionType(_objectSpread(_objectSpread({}, _config2), {}, {\n        types: function types() {\n          return sortTypes(_config2.types);\n        }\n      }));\n    }\n\n    if (isEnumType(type)) {\n      var _config3 = type.toConfig();\n\n      return new GraphQLEnumType(_objectSpread(_objectSpread({}, _config3), {}, {\n        values: sortObjMap(_config3.values)\n      }));\n    } // istanbul ignore else (See: 'https://github.com/graphql/graphql-js/issues/2618')\n\n\n    if (isInputObjectType(type)) {\n      var _config4 = type.toConfig();\n\n      return new GraphQLInputObjectType(_objectSpread(_objectSpread({}, _config4), {}, {\n        fields: function fields() {\n          return sortInputFields(_config4.fields);\n        }\n      }));\n    } // istanbul ignore next (Not reachable. All possible types have been considered)\n\n\n    false || invariant(0, 'Unexpected type: ' + inspect(type));\n  }\n}\n\nfunction sortObjMap(map, sortValueFn) {\n  var sortedMap = Object.create(null);\n  var sortedKeys = sortBy(Object.keys(map), function (x) {\n    return x;\n  });\n\n  for (var _i2 = 0; _i2 < sortedKeys.length; _i2++) {\n    var key = sortedKeys[_i2];\n    var value = map[key];\n    sortedMap[key] = sortValueFn ? sortValueFn(value) : value;\n  }\n\n  return sortedMap;\n}\n\nfunction sortByName(array) {\n  return sortBy(array, function (obj) {\n    return obj.name;\n  });\n}\n\nfunction sortBy(array, mapToKey) {\n  return array.slice().sort(function (obj1, obj2) {\n    var key1 = mapToKey(obj1);\n    var key2 = mapToKey(obj2);\n    return naturalCompare(key1, key2);\n  });\n}\n","import objectValues from \"../polyfills/objectValues.mjs\";\nimport inspect from \"../jsutils/inspect.mjs\";\nimport invariant from \"../jsutils/invariant.mjs\";\nimport { print } from \"../language/printer.mjs\";\nimport { printBlockString } from \"../language/blockString.mjs\";\nimport { isIntrospectionType } from \"../type/introspection.mjs\";\nimport { GraphQLString, isSpecifiedScalarType } from \"../type/scalars.mjs\";\nimport { DEFAULT_DEPRECATION_REASON, isSpecifiedDirective } from \"../type/directives.mjs\";\nimport { isScalarType, isObjectType, isInterfaceType, isUnionType, isEnumType, isInputObjectType } from \"../type/definition.mjs\";\nimport { astFromValue } from \"./astFromValue.mjs\";\n\n/**\n * Accepts options as a second argument:\n *\n *    - commentDescriptions:\n *        Provide true to use preceding comments as the description.\n *\n */\nexport function printSchema(schema, options) {\n  return printFilteredSchema(schema, function (n) {\n    return !isSpecifiedDirective(n);\n  }, isDefinedType, options);\n}\nexport function printIntrospectionSchema(schema, options) {\n  return printFilteredSchema(schema, isSpecifiedDirective, isIntrospectionType, options);\n}\n\nfunction isDefinedType(type) {\n  return !isSpecifiedScalarType(type) && !isIntrospectionType(type);\n}\n\nfunction printFilteredSchema(schema, directiveFilter, typeFilter, options) {\n  var directives = schema.getDirectives().filter(directiveFilter);\n  var types = objectValues(schema.getTypeMap()).filter(typeFilter);\n  return [printSchemaDefinition(schema)].concat(directives.map(function (directive) {\n    return printDirective(directive, options);\n  }), types.map(function (type) {\n    return printType(type, options);\n  })).filter(Boolean).join('\\n\\n') + '\\n';\n}\n\nfunction printSchemaDefinition(schema) {\n  if (schema.description == null && isSchemaOfCommonNames(schema)) {\n    return;\n  }\n\n  var operationTypes = [];\n  var queryType = schema.getQueryType();\n\n  if (queryType) {\n    operationTypes.push(\"  query: \".concat(queryType.name));\n  }\n\n  var mutationType = schema.getMutationType();\n\n  if (mutationType) {\n    operationTypes.push(\"  mutation: \".concat(mutationType.name));\n  }\n\n  var subscriptionType = schema.getSubscriptionType();\n\n  if (subscriptionType) {\n    operationTypes.push(\"  subscription: \".concat(subscriptionType.name));\n  }\n\n  return printDescription({}, schema) + \"schema {\\n\".concat(operationTypes.join('\\n'), \"\\n}\");\n}\n/**\n * GraphQL schema define root types for each type of operation. These types are\n * the same as any other type and can be named in any manner, however there is\n * a common naming convention:\n *\n *   schema {\n *     query: Query\n *     mutation: Mutation\n *   }\n *\n * When using this naming convention, the schema description can be omitted.\n */\n\n\nfunction isSchemaOfCommonNames(schema) {\n  var queryType = schema.getQueryType();\n\n  if (queryType && queryType.name !== 'Query') {\n    return false;\n  }\n\n  var mutationType = schema.getMutationType();\n\n  if (mutationType && mutationType.name !== 'Mutation') {\n    return false;\n  }\n\n  var subscriptionType = schema.getSubscriptionType();\n\n  if (subscriptionType && subscriptionType.name !== 'Subscription') {\n    return false;\n  }\n\n  return true;\n}\n\nexport function printType(type, options) {\n  if (isScalarType(type)) {\n    return printScalar(type, options);\n  }\n\n  if (isObjectType(type)) {\n    return printObject(type, options);\n  }\n\n  if (isInterfaceType(type)) {\n    return printInterface(type, options);\n  }\n\n  if (isUnionType(type)) {\n    return printUnion(type, options);\n  }\n\n  if (isEnumType(type)) {\n    return printEnum(type, options);\n  } // istanbul ignore else (See: 'https://github.com/graphql/graphql-js/issues/2618')\n\n\n  if (isInputObjectType(type)) {\n    return printInputObject(type, options);\n  } // istanbul ignore next (Not reachable. All possible types have been considered)\n\n\n  false || invariant(0, 'Unexpected type: ' + inspect(type));\n}\n\nfunction printScalar(type, options) {\n  return printDescription(options, type) + \"scalar \".concat(type.name) + printSpecifiedByUrl(type);\n}\n\nfunction printImplementedInterfaces(type) {\n  var interfaces = type.getInterfaces();\n  return interfaces.length ? ' implements ' + interfaces.map(function (i) {\n    return i.name;\n  }).join(' & ') : '';\n}\n\nfunction printObject(type, options) {\n  return printDescription(options, type) + \"type \".concat(type.name) + printImplementedInterfaces(type) + printFields(options, type);\n}\n\nfunction printInterface(type, options) {\n  return printDescription(options, type) + \"interface \".concat(type.name) + printImplementedInterfaces(type) + printFields(options, type);\n}\n\nfunction printUnion(type, options) {\n  var types = type.getTypes();\n  var possibleTypes = types.length ? ' = ' + types.join(' | ') : '';\n  return printDescription(options, type) + 'union ' + type.name + possibleTypes;\n}\n\nfunction printEnum(type, options) {\n  var values = type.getValues().map(function (value, i) {\n    return printDescription(options, value, '  ', !i) + '  ' + value.name + printDeprecated(value.deprecationReason);\n  });\n  return printDescription(options, type) + \"enum \".concat(type.name) + printBlock(values);\n}\n\nfunction printInputObject(type, options) {\n  var fields = objectValues(type.getFields()).map(function (f, i) {\n    return printDescription(options, f, '  ', !i) + '  ' + printInputValue(f);\n  });\n  return printDescription(options, type) + \"input \".concat(type.name) + printBlock(fields);\n}\n\nfunction printFields(options, type) {\n  var fields = objectValues(type.getFields()).map(function (f, i) {\n    return printDescription(options, f, '  ', !i) + '  ' + f.name + printArgs(options, f.args, '  ') + ': ' + String(f.type) + printDeprecated(f.deprecationReason);\n  });\n  return printBlock(fields);\n}\n\nfunction printBlock(items) {\n  return items.length !== 0 ? ' {\\n' + items.join('\\n') + '\\n}' : '';\n}\n\nfunction printArgs(options, args) {\n  var indentation = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n\n  if (args.length === 0) {\n    return '';\n  } // If every arg does not have a description, print them on one line.\n\n\n  if (args.every(function (arg) {\n    return !arg.description;\n  })) {\n    return '(' + args.map(printInputValue).join(', ') + ')';\n  }\n\n  return '(\\n' + args.map(function (arg, i) {\n    return printDescription(options, arg, '  ' + indentation, !i) + '  ' + indentation + printInputValue(arg);\n  }).join('\\n') + '\\n' + indentation + ')';\n}\n\nfunction printInputValue(arg) {\n  var defaultAST = astFromValue(arg.defaultValue, arg.type);\n  var argDecl = arg.name + ': ' + String(arg.type);\n\n  if (defaultAST) {\n    argDecl += \" = \".concat(print(defaultAST));\n  }\n\n  return argDecl + printDeprecated(arg.deprecationReason);\n}\n\nfunction printDirective(directive, options) {\n  return printDescription(options, directive) + 'directive @' + directive.name + printArgs(options, directive.args) + (directive.isRepeatable ? ' repeatable' : '') + ' on ' + directive.locations.join(' | ');\n}\n\nfunction printDeprecated(reason) {\n  if (reason == null) {\n    return '';\n  }\n\n  var reasonAST = astFromValue(reason, GraphQLString);\n\n  if (reasonAST && reason !== DEFAULT_DEPRECATION_REASON) {\n    return ' @deprecated(reason: ' + print(reasonAST) + ')';\n  }\n\n  return ' @deprecated';\n}\n\nfunction printSpecifiedByUrl(scalar) {\n  if (scalar.specifiedByUrl == null) {\n    return '';\n  }\n\n  var url = scalar.specifiedByUrl;\n  var urlAST = astFromValue(url, GraphQLString);\n  urlAST || invariant(0, 'Unexpected null value returned from `astFromValue` for specifiedByUrl');\n  return ' @specifiedBy(url: ' + print(urlAST) + ')';\n}\n\nfunction printDescription(options, def) {\n  var indentation = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n  var firstInBlock = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n  var description = def.description;\n\n  if (description == null) {\n    return '';\n  }\n\n  if ((options === null || options === void 0 ? void 0 : options.commentDescriptions) === true) {\n    return printDescriptionWithComments(description, indentation, firstInBlock);\n  }\n\n  var preferMultipleLines = description.length > 70;\n  var blockString = printBlockString(description, '', preferMultipleLines);\n  var prefix = indentation && !firstInBlock ? '\\n' + indentation : indentation;\n  return prefix + blockString.replace(/\\n/g, '\\n' + indentation) + '\\n';\n}\n\nfunction printDescriptionWithComments(description, indentation, firstInBlock) {\n  var prefix = indentation && !firstInBlock ? '\\n' : '';\n  var comment = description.split('\\n').map(function (line) {\n    return indentation + (line !== '' ? '# ' + line : '#');\n  }).join('\\n');\n  return prefix + comment + '\\n';\n}\n","/**\n * Provided a collection of ASTs, presumably each from different files,\n * concatenate the ASTs together into batched AST, useful for validating many\n * GraphQL source files which together represent one conceptual application.\n */\nexport function concatAST(documents) {\n  var definitions = [];\n\n  for (var _i2 = 0; _i2 < documents.length; _i2++) {\n    var doc = documents[_i2];\n    definitions = definitions.concat(doc.definitions);\n  }\n\n  return {\n    kind: 'Document',\n    definitions: definitions\n  };\n}\n","import { Kind } from \"../language/kinds.mjs\";\nimport { visit } from \"../language/visitor.mjs\";\n/**\n * separateOperations accepts a single AST document which may contain many\n * operations and fragments and returns a collection of AST documents each of\n * which contains a single operation as well the fragment definitions it\n * refers to.\n */\n\nexport function separateOperations(documentAST) {\n  var operations = [];\n  var depGraph = Object.create(null); // Populate metadata and build a dependency graph.\n\n  for (var _i2 = 0, _documentAST$definiti2 = documentAST.definitions; _i2 < _documentAST$definiti2.length; _i2++) {\n    var definitionNode = _documentAST$definiti2[_i2];\n\n    switch (definitionNode.kind) {\n      case Kind.OPERATION_DEFINITION:\n        operations.push(definitionNode);\n        break;\n\n      case Kind.FRAGMENT_DEFINITION:\n        depGraph[definitionNode.name.value] = collectDependencies(definitionNode.selectionSet);\n        break;\n    }\n  } // For each operation, produce a new synthesized AST which includes only what\n  // is necessary for completing that operation.\n\n\n  var separatedDocumentASTs = Object.create(null);\n\n  var _loop = function _loop(_i4) {\n    var operation = operations[_i4];\n    var dependencies = new Set();\n\n    for (var _i6 = 0, _collectDependencies2 = collectDependencies(operation.selectionSet); _i6 < _collectDependencies2.length; _i6++) {\n      var fragmentName = _collectDependencies2[_i6];\n      collectTransitiveDependencies(dependencies, depGraph, fragmentName);\n    } // Provides the empty string for anonymous operations.\n\n\n    var operationName = operation.name ? operation.name.value : ''; // The list of definition nodes to be included for this operation, sorted\n    // to retain the same order as the original document.\n\n    separatedDocumentASTs[operationName] = {\n      kind: Kind.DOCUMENT,\n      definitions: documentAST.definitions.filter(function (node) {\n        return node === operation || node.kind === Kind.FRAGMENT_DEFINITION && dependencies.has(node.name.value);\n      })\n    };\n  };\n\n  for (var _i4 = 0; _i4 < operations.length; _i4++) {\n    _loop(_i4);\n  }\n\n  return separatedDocumentASTs;\n}\n\n// From a dependency graph, collects a list of transitive dependencies by\n// recursing through a dependency graph.\nfunction collectTransitiveDependencies(collected, depGraph, fromName) {\n  if (!collected.has(fromName)) {\n    collected.add(fromName);\n    var immediateDeps = depGraph[fromName];\n\n    if (immediateDeps !== undefined) {\n      for (var _i8 = 0; _i8 < immediateDeps.length; _i8++) {\n        var toName = immediateDeps[_i8];\n        collectTransitiveDependencies(collected, depGraph, toName);\n      }\n    }\n  }\n}\n\nfunction collectDependencies(selectionSet) {\n  var dependencies = [];\n  visit(selectionSet, {\n    FragmentSpread: function FragmentSpread(node) {\n      dependencies.push(node.name.value);\n    }\n  });\n  return dependencies;\n}\n","import { Source, isSource } from \"../language/source.mjs\";\nimport { TokenKind } from \"../language/tokenKind.mjs\";\nimport { Lexer, isPunctuatorTokenKind } from \"../language/lexer.mjs\";\nimport { dedentBlockStringValue, getBlockStringIndentation } from \"../language/blockString.mjs\";\n/**\n * Strips characters that are not significant to the validity or execution\n * of a GraphQL document:\n *   - UnicodeBOM\n *   - WhiteSpace\n *   - LineTerminator\n *   - Comment\n *   - Comma\n *   - BlockString indentation\n *\n * Note: It is required to have a delimiter character between neighboring\n * non-punctuator tokens and this function always uses single space as delimiter.\n *\n * It is guaranteed that both input and output documents if parsed would result\n * in the exact same AST except for nodes location.\n *\n * Warning: It is guaranteed that this function will always produce stable results.\n * However, it's not guaranteed that it will stay the same between different\n * releases due to bugfixes or changes in the GraphQL specification.\n *\n * Query example:\n *\n * query SomeQuery($foo: String!, $bar: String) {\n *   someField(foo: $foo, bar: $bar) {\n *     a\n *     b {\n *       c\n *       d\n *     }\n *   }\n * }\n *\n * Becomes:\n *\n * query SomeQuery($foo:String!$bar:String){someField(foo:$foo bar:$bar){a b{c d}}}\n *\n * SDL example:\n *\n * \"\"\"\n * Type description\n * \"\"\"\n * type Foo {\n *   \"\"\"\n *   Field description\n *   \"\"\"\n *   bar: String\n * }\n *\n * Becomes:\n *\n * \"\"\"Type description\"\"\" type Foo{\"\"\"Field description\"\"\" bar:String}\n */\n\nexport function stripIgnoredCharacters(source) {\n  var sourceObj = isSource(source) ? source : new Source(source);\n  var body = sourceObj.body;\n  var lexer = new Lexer(sourceObj);\n  var strippedBody = '';\n  var wasLastAddedTokenNonPunctuator = false;\n\n  while (lexer.advance().kind !== TokenKind.EOF) {\n    var currentToken = lexer.token;\n    var tokenKind = currentToken.kind;\n    /**\n     * Every two non-punctuator tokens should have space between them.\n     * Also prevent case of non-punctuator token following by spread resulting\n     * in invalid token (e.g. `1...` is invalid Float token).\n     */\n\n    var isNonPunctuator = !isPunctuatorTokenKind(currentToken.kind);\n\n    if (wasLastAddedTokenNonPunctuator) {\n      if (isNonPunctuator || currentToken.kind === TokenKind.SPREAD) {\n        strippedBody += ' ';\n      }\n    }\n\n    var tokenBody = body.slice(currentToken.start, currentToken.end);\n\n    if (tokenKind === TokenKind.BLOCK_STRING) {\n      strippedBody += dedentBlockString(tokenBody);\n    } else {\n      strippedBody += tokenBody;\n    }\n\n    wasLastAddedTokenNonPunctuator = isNonPunctuator;\n  }\n\n  return strippedBody;\n}\n\nfunction dedentBlockString(blockStr) {\n  // skip leading and trailing triple quotations\n  var rawStr = blockStr.slice(3, -3);\n  var body = dedentBlockStringValue(rawStr);\n\n  if (getBlockStringIndentation(body) > 0) {\n    body = '\\n' + body;\n  }\n\n  var lastChar = body[body.length - 1];\n  var hasTrailingQuote = lastChar === '\"' && body.slice(-4) !== '\\\\\"\"\"';\n\n  if (hasTrailingQuote || lastChar === '\\\\') {\n    body += '\\n';\n  }\n\n  return '\"\"\"' + body + '\"\"\"';\n}\n","function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport objectValues from \"../polyfills/objectValues.mjs\";\nimport keyMap from \"../jsutils/keyMap.mjs\";\nimport inspect from \"../jsutils/inspect.mjs\";\nimport invariant from \"../jsutils/invariant.mjs\";\nimport naturalCompare from \"../jsutils/naturalCompare.mjs\";\nimport { print } from \"../language/printer.mjs\";\nimport { visit } from \"../language/visitor.mjs\";\nimport { isSpecifiedScalarType } from \"../type/scalars.mjs\";\nimport { isScalarType, isObjectType, isInterfaceType, isUnionType, isEnumType, isInputObjectType, isNonNullType, isListType, isNamedType, isRequiredArgument, isRequiredInputField } from \"../type/definition.mjs\";\nimport { astFromValue } from \"./astFromValue.mjs\";\nexport var BreakingChangeType = Object.freeze({\n  TYPE_REMOVED: 'TYPE_REMOVED',\n  TYPE_CHANGED_KIND: 'TYPE_CHANGED_KIND',\n  TYPE_REMOVED_FROM_UNION: 'TYPE_REMOVED_FROM_UNION',\n  VALUE_REMOVED_FROM_ENUM: 'VALUE_REMOVED_FROM_ENUM',\n  REQUIRED_INPUT_FIELD_ADDED: 'REQUIRED_INPUT_FIELD_ADDED',\n  IMPLEMENTED_INTERFACE_REMOVED: 'IMPLEMENTED_INTERFACE_REMOVED',\n  FIELD_REMOVED: 'FIELD_REMOVED',\n  FIELD_CHANGED_KIND: 'FIELD_CHANGED_KIND',\n  REQUIRED_ARG_ADDED: 'REQUIRED_ARG_ADDED',\n  ARG_REMOVED: 'ARG_REMOVED',\n  ARG_CHANGED_KIND: 'ARG_CHANGED_KIND',\n  DIRECTIVE_REMOVED: 'DIRECTIVE_REMOVED',\n  DIRECTIVE_ARG_REMOVED: 'DIRECTIVE_ARG_REMOVED',\n  REQUIRED_DIRECTIVE_ARG_ADDED: 'REQUIRED_DIRECTIVE_ARG_ADDED',\n  DIRECTIVE_REPEATABLE_REMOVED: 'DIRECTIVE_REPEATABLE_REMOVED',\n  DIRECTIVE_LOCATION_REMOVED: 'DIRECTIVE_LOCATION_REMOVED'\n});\nexport var DangerousChangeType = Object.freeze({\n  VALUE_ADDED_TO_ENUM: 'VALUE_ADDED_TO_ENUM',\n  TYPE_ADDED_TO_UNION: 'TYPE_ADDED_TO_UNION',\n  OPTIONAL_INPUT_FIELD_ADDED: 'OPTIONAL_INPUT_FIELD_ADDED',\n  OPTIONAL_ARG_ADDED: 'OPTIONAL_ARG_ADDED',\n  IMPLEMENTED_INTERFACE_ADDED: 'IMPLEMENTED_INTERFACE_ADDED',\n  ARG_DEFAULT_VALUE_CHANGE: 'ARG_DEFAULT_VALUE_CHANGE'\n});\n\n/**\n * Given two schemas, returns an Array containing descriptions of all the types\n * of breaking changes covered by the other functions down below.\n */\nexport function findBreakingChanges(oldSchema, newSchema) {\n  var breakingChanges = findSchemaChanges(oldSchema, newSchema).filter(function (change) {\n    return change.type in BreakingChangeType;\n  });\n  return breakingChanges;\n}\n/**\n * Given two schemas, returns an Array containing descriptions of all the types\n * of potentially dangerous changes covered by the other functions down below.\n */\n\nexport function findDangerousChanges(oldSchema, newSchema) {\n  var dangerousChanges = findSchemaChanges(oldSchema, newSchema).filter(function (change) {\n    return change.type in DangerousChangeType;\n  });\n  return dangerousChanges;\n}\n\nfunction findSchemaChanges(oldSchema, newSchema) {\n  return [].concat(findTypeChanges(oldSchema, newSchema), findDirectiveChanges(oldSchema, newSchema));\n}\n\nfunction findDirectiveChanges(oldSchema, newSchema) {\n  var schemaChanges = [];\n  var directivesDiff = diff(oldSchema.getDirectives(), newSchema.getDirectives());\n\n  for (var _i2 = 0, _directivesDiff$remov2 = directivesDiff.removed; _i2 < _directivesDiff$remov2.length; _i2++) {\n    var oldDirective = _directivesDiff$remov2[_i2];\n    schemaChanges.push({\n      type: BreakingChangeType.DIRECTIVE_REMOVED,\n      description: \"\".concat(oldDirective.name, \" was removed.\")\n    });\n  }\n\n  for (var _i4 = 0, _directivesDiff$persi2 = directivesDiff.persisted; _i4 < _directivesDiff$persi2.length; _i4++) {\n    var _ref2 = _directivesDiff$persi2[_i4];\n    var _oldDirective = _ref2[0];\n    var newDirective = _ref2[1];\n    var argsDiff = diff(_oldDirective.args, newDirective.args);\n\n    for (var _i6 = 0, _argsDiff$added2 = argsDiff.added; _i6 < _argsDiff$added2.length; _i6++) {\n      var newArg = _argsDiff$added2[_i6];\n\n      if (isRequiredArgument(newArg)) {\n        schemaChanges.push({\n          type: BreakingChangeType.REQUIRED_DIRECTIVE_ARG_ADDED,\n          description: \"A required arg \".concat(newArg.name, \" on directive \").concat(_oldDirective.name, \" was added.\")\n        });\n      }\n    }\n\n    for (var _i8 = 0, _argsDiff$removed2 = argsDiff.removed; _i8 < _argsDiff$removed2.length; _i8++) {\n      var oldArg = _argsDiff$removed2[_i8];\n      schemaChanges.push({\n        type: BreakingChangeType.DIRECTIVE_ARG_REMOVED,\n        description: \"\".concat(oldArg.name, \" was removed from \").concat(_oldDirective.name, \".\")\n      });\n    }\n\n    if (_oldDirective.isRepeatable && !newDirective.isRepeatable) {\n      schemaChanges.push({\n        type: BreakingChangeType.DIRECTIVE_REPEATABLE_REMOVED,\n        description: \"Repeatable flag was removed from \".concat(_oldDirective.name, \".\")\n      });\n    }\n\n    for (var _i10 = 0, _oldDirective$locatio2 = _oldDirective.locations; _i10 < _oldDirective$locatio2.length; _i10++) {\n      var location = _oldDirective$locatio2[_i10];\n\n      if (newDirective.locations.indexOf(location) === -1) {\n        schemaChanges.push({\n          type: BreakingChangeType.DIRECTIVE_LOCATION_REMOVED,\n          description: \"\".concat(location, \" was removed from \").concat(_oldDirective.name, \".\")\n        });\n      }\n    }\n  }\n\n  return schemaChanges;\n}\n\nfunction findTypeChanges(oldSchema, newSchema) {\n  var schemaChanges = [];\n  var typesDiff = diff(objectValues(oldSchema.getTypeMap()), objectValues(newSchema.getTypeMap()));\n\n  for (var _i12 = 0, _typesDiff$removed2 = typesDiff.removed; _i12 < _typesDiff$removed2.length; _i12++) {\n    var oldType = _typesDiff$removed2[_i12];\n    schemaChanges.push({\n      type: BreakingChangeType.TYPE_REMOVED,\n      description: isSpecifiedScalarType(oldType) ? \"Standard scalar \".concat(oldType.name, \" was removed because it is not referenced anymore.\") : \"\".concat(oldType.name, \" was removed.\")\n    });\n  }\n\n  for (var _i14 = 0, _typesDiff$persisted2 = typesDiff.persisted; _i14 < _typesDiff$persisted2.length; _i14++) {\n    var _ref4 = _typesDiff$persisted2[_i14];\n    var _oldType = _ref4[0];\n    var newType = _ref4[1];\n\n    if (isEnumType(_oldType) && isEnumType(newType)) {\n      schemaChanges.push.apply(schemaChanges, findEnumTypeChanges(_oldType, newType));\n    } else if (isUnionType(_oldType) && isUnionType(newType)) {\n      schemaChanges.push.apply(schemaChanges, findUnionTypeChanges(_oldType, newType));\n    } else if (isInputObjectType(_oldType) && isInputObjectType(newType)) {\n      schemaChanges.push.apply(schemaChanges, findInputObjectTypeChanges(_oldType, newType));\n    } else if (isObjectType(_oldType) && isObjectType(newType)) {\n      schemaChanges.push.apply(schemaChanges, findFieldChanges(_oldType, newType).concat(findImplementedInterfacesChanges(_oldType, newType)));\n    } else if (isInterfaceType(_oldType) && isInterfaceType(newType)) {\n      schemaChanges.push.apply(schemaChanges, findFieldChanges(_oldType, newType).concat(findImplementedInterfacesChanges(_oldType, newType)));\n    } else if (_oldType.constructor !== newType.constructor) {\n      schemaChanges.push({\n        type: BreakingChangeType.TYPE_CHANGED_KIND,\n        description: \"\".concat(_oldType.name, \" changed from \") + \"\".concat(typeKindName(_oldType), \" to \").concat(typeKindName(newType), \".\")\n      });\n    }\n  }\n\n  return schemaChanges;\n}\n\nfunction findInputObjectTypeChanges(oldType, newType) {\n  var schemaChanges = [];\n  var fieldsDiff = diff(objectValues(oldType.getFields()), objectValues(newType.getFields()));\n\n  for (var _i16 = 0, _fieldsDiff$added2 = fieldsDiff.added; _i16 < _fieldsDiff$added2.length; _i16++) {\n    var newField = _fieldsDiff$added2[_i16];\n\n    if (isRequiredInputField(newField)) {\n      schemaChanges.push({\n        type: BreakingChangeType.REQUIRED_INPUT_FIELD_ADDED,\n        description: \"A required field \".concat(newField.name, \" on input type \").concat(oldType.name, \" was added.\")\n      });\n    } else {\n      schemaChanges.push({\n        type: DangerousChangeType.OPTIONAL_INPUT_FIELD_ADDED,\n        description: \"An optional field \".concat(newField.name, \" on input type \").concat(oldType.name, \" was added.\")\n      });\n    }\n  }\n\n  for (var _i18 = 0, _fieldsDiff$removed2 = fieldsDiff.removed; _i18 < _fieldsDiff$removed2.length; _i18++) {\n    var oldField = _fieldsDiff$removed2[_i18];\n    schemaChanges.push({\n      type: BreakingChangeType.FIELD_REMOVED,\n      description: \"\".concat(oldType.name, \".\").concat(oldField.name, \" was removed.\")\n    });\n  }\n\n  for (var _i20 = 0, _fieldsDiff$persisted2 = fieldsDiff.persisted; _i20 < _fieldsDiff$persisted2.length; _i20++) {\n    var _ref6 = _fieldsDiff$persisted2[_i20];\n    var _oldField = _ref6[0];\n    var _newField = _ref6[1];\n    var isSafe = isChangeSafeForInputObjectFieldOrFieldArg(_oldField.type, _newField.type);\n\n    if (!isSafe) {\n      schemaChanges.push({\n        type: BreakingChangeType.FIELD_CHANGED_KIND,\n        description: \"\".concat(oldType.name, \".\").concat(_oldField.name, \" changed type from \") + \"\".concat(String(_oldField.type), \" to \").concat(String(_newField.type), \".\")\n      });\n    }\n  }\n\n  return schemaChanges;\n}\n\nfunction findUnionTypeChanges(oldType, newType) {\n  var schemaChanges = [];\n  var possibleTypesDiff = diff(oldType.getTypes(), newType.getTypes());\n\n  for (var _i22 = 0, _possibleTypesDiff$ad2 = possibleTypesDiff.added; _i22 < _possibleTypesDiff$ad2.length; _i22++) {\n    var newPossibleType = _possibleTypesDiff$ad2[_i22];\n    schemaChanges.push({\n      type: DangerousChangeType.TYPE_ADDED_TO_UNION,\n      description: \"\".concat(newPossibleType.name, \" was added to union type \").concat(oldType.name, \".\")\n    });\n  }\n\n  for (var _i24 = 0, _possibleTypesDiff$re2 = possibleTypesDiff.removed; _i24 < _possibleTypesDiff$re2.length; _i24++) {\n    var oldPossibleType = _possibleTypesDiff$re2[_i24];\n    schemaChanges.push({\n      type: BreakingChangeType.TYPE_REMOVED_FROM_UNION,\n      description: \"\".concat(oldPossibleType.name, \" was removed from union type \").concat(oldType.name, \".\")\n    });\n  }\n\n  return schemaChanges;\n}\n\nfunction findEnumTypeChanges(oldType, newType) {\n  var schemaChanges = [];\n  var valuesDiff = diff(oldType.getValues(), newType.getValues());\n\n  for (var _i26 = 0, _valuesDiff$added2 = valuesDiff.added; _i26 < _valuesDiff$added2.length; _i26++) {\n    var newValue = _valuesDiff$added2[_i26];\n    schemaChanges.push({\n      type: DangerousChangeType.VALUE_ADDED_TO_ENUM,\n      description: \"\".concat(newValue.name, \" was added to enum type \").concat(oldType.name, \".\")\n    });\n  }\n\n  for (var _i28 = 0, _valuesDiff$removed2 = valuesDiff.removed; _i28 < _valuesDiff$removed2.length; _i28++) {\n    var oldValue = _valuesDiff$removed2[_i28];\n    schemaChanges.push({\n      type: BreakingChangeType.VALUE_REMOVED_FROM_ENUM,\n      description: \"\".concat(oldValue.name, \" was removed from enum type \").concat(oldType.name, \".\")\n    });\n  }\n\n  return schemaChanges;\n}\n\nfunction findImplementedInterfacesChanges(oldType, newType) {\n  var schemaChanges = [];\n  var interfacesDiff = diff(oldType.getInterfaces(), newType.getInterfaces());\n\n  for (var _i30 = 0, _interfacesDiff$added2 = interfacesDiff.added; _i30 < _interfacesDiff$added2.length; _i30++) {\n    var newInterface = _interfacesDiff$added2[_i30];\n    schemaChanges.push({\n      type: DangerousChangeType.IMPLEMENTED_INTERFACE_ADDED,\n      description: \"\".concat(newInterface.name, \" added to interfaces implemented by \").concat(oldType.name, \".\")\n    });\n  }\n\n  for (var _i32 = 0, _interfacesDiff$remov2 = interfacesDiff.removed; _i32 < _interfacesDiff$remov2.length; _i32++) {\n    var oldInterface = _interfacesDiff$remov2[_i32];\n    schemaChanges.push({\n      type: BreakingChangeType.IMPLEMENTED_INTERFACE_REMOVED,\n      description: \"\".concat(oldType.name, \" no longer implements interface \").concat(oldInterface.name, \".\")\n    });\n  }\n\n  return schemaChanges;\n}\n\nfunction findFieldChanges(oldType, newType) {\n  var schemaChanges = [];\n  var fieldsDiff = diff(objectValues(oldType.getFields()), objectValues(newType.getFields()));\n\n  for (var _i34 = 0, _fieldsDiff$removed4 = fieldsDiff.removed; _i34 < _fieldsDiff$removed4.length; _i34++) {\n    var oldField = _fieldsDiff$removed4[_i34];\n    schemaChanges.push({\n      type: BreakingChangeType.FIELD_REMOVED,\n      description: \"\".concat(oldType.name, \".\").concat(oldField.name, \" was removed.\")\n    });\n  }\n\n  for (var _i36 = 0, _fieldsDiff$persisted4 = fieldsDiff.persisted; _i36 < _fieldsDiff$persisted4.length; _i36++) {\n    var _ref8 = _fieldsDiff$persisted4[_i36];\n    var _oldField2 = _ref8[0];\n    var newField = _ref8[1];\n    schemaChanges.push.apply(schemaChanges, findArgChanges(oldType, _oldField2, newField));\n    var isSafe = isChangeSafeForObjectOrInterfaceField(_oldField2.type, newField.type);\n\n    if (!isSafe) {\n      schemaChanges.push({\n        type: BreakingChangeType.FIELD_CHANGED_KIND,\n        description: \"\".concat(oldType.name, \".\").concat(_oldField2.name, \" changed type from \") + \"\".concat(String(_oldField2.type), \" to \").concat(String(newField.type), \".\")\n      });\n    }\n  }\n\n  return schemaChanges;\n}\n\nfunction findArgChanges(oldType, oldField, newField) {\n  var schemaChanges = [];\n  var argsDiff = diff(oldField.args, newField.args);\n\n  for (var _i38 = 0, _argsDiff$removed4 = argsDiff.removed; _i38 < _argsDiff$removed4.length; _i38++) {\n    var oldArg = _argsDiff$removed4[_i38];\n    schemaChanges.push({\n      type: BreakingChangeType.ARG_REMOVED,\n      description: \"\".concat(oldType.name, \".\").concat(oldField.name, \" arg \").concat(oldArg.name, \" was removed.\")\n    });\n  }\n\n  for (var _i40 = 0, _argsDiff$persisted2 = argsDiff.persisted; _i40 < _argsDiff$persisted2.length; _i40++) {\n    var _ref10 = _argsDiff$persisted2[_i40];\n    var _oldArg = _ref10[0];\n    var newArg = _ref10[1];\n    var isSafe = isChangeSafeForInputObjectFieldOrFieldArg(_oldArg.type, newArg.type);\n\n    if (!isSafe) {\n      schemaChanges.push({\n        type: BreakingChangeType.ARG_CHANGED_KIND,\n        description: \"\".concat(oldType.name, \".\").concat(oldField.name, \" arg \").concat(_oldArg.name, \" has changed type from \") + \"\".concat(String(_oldArg.type), \" to \").concat(String(newArg.type), \".\")\n      });\n    } else if (_oldArg.defaultValue !== undefined) {\n      if (newArg.defaultValue === undefined) {\n        schemaChanges.push({\n          type: DangerousChangeType.ARG_DEFAULT_VALUE_CHANGE,\n          description: \"\".concat(oldType.name, \".\").concat(oldField.name, \" arg \").concat(_oldArg.name, \" defaultValue was removed.\")\n        });\n      } else {\n        // Since we looking only for client's observable changes we should\n        // compare default values in the same representation as they are\n        // represented inside introspection.\n        var oldValueStr = stringifyValue(_oldArg.defaultValue, _oldArg.type);\n        var newValueStr = stringifyValue(newArg.defaultValue, newArg.type);\n\n        if (oldValueStr !== newValueStr) {\n          schemaChanges.push({\n            type: DangerousChangeType.ARG_DEFAULT_VALUE_CHANGE,\n            description: \"\".concat(oldType.name, \".\").concat(oldField.name, \" arg \").concat(_oldArg.name, \" has changed defaultValue from \").concat(oldValueStr, \" to \").concat(newValueStr, \".\")\n          });\n        }\n      }\n    }\n  }\n\n  for (var _i42 = 0, _argsDiff$added4 = argsDiff.added; _i42 < _argsDiff$added4.length; _i42++) {\n    var _newArg = _argsDiff$added4[_i42];\n\n    if (isRequiredArgument(_newArg)) {\n      schemaChanges.push({\n        type: BreakingChangeType.REQUIRED_ARG_ADDED,\n        description: \"A required arg \".concat(_newArg.name, \" on \").concat(oldType.name, \".\").concat(oldField.name, \" was added.\")\n      });\n    } else {\n      schemaChanges.push({\n        type: DangerousChangeType.OPTIONAL_ARG_ADDED,\n        description: \"An optional arg \".concat(_newArg.name, \" on \").concat(oldType.name, \".\").concat(oldField.name, \" was added.\")\n      });\n    }\n  }\n\n  return schemaChanges;\n}\n\nfunction isChangeSafeForObjectOrInterfaceField(oldType, newType) {\n  if (isListType(oldType)) {\n    return (// if they're both lists, make sure the underlying types are compatible\n      isListType(newType) && isChangeSafeForObjectOrInterfaceField(oldType.ofType, newType.ofType) || // moving from nullable to non-null of the same underlying type is safe\n      isNonNullType(newType) && isChangeSafeForObjectOrInterfaceField(oldType, newType.ofType)\n    );\n  }\n\n  if (isNonNullType(oldType)) {\n    // if they're both non-null, make sure the underlying types are compatible\n    return isNonNullType(newType) && isChangeSafeForObjectOrInterfaceField(oldType.ofType, newType.ofType);\n  }\n\n  return (// if they're both named types, see if their names are equivalent\n    isNamedType(newType) && oldType.name === newType.name || // moving from nullable to non-null of the same underlying type is safe\n    isNonNullType(newType) && isChangeSafeForObjectOrInterfaceField(oldType, newType.ofType)\n  );\n}\n\nfunction isChangeSafeForInputObjectFieldOrFieldArg(oldType, newType) {\n  if (isListType(oldType)) {\n    // if they're both lists, make sure the underlying types are compatible\n    return isListType(newType) && isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType.ofType);\n  }\n\n  if (isNonNullType(oldType)) {\n    return (// if they're both non-null, make sure the underlying types are\n      // compatible\n      isNonNullType(newType) && isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType.ofType) || // moving from non-null to nullable of the same underlying type is safe\n      !isNonNullType(newType) && isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType)\n    );\n  } // if they're both named types, see if their names are equivalent\n\n\n  return isNamedType(newType) && oldType.name === newType.name;\n}\n\nfunction typeKindName(type) {\n  if (isScalarType(type)) {\n    return 'a Scalar type';\n  }\n\n  if (isObjectType(type)) {\n    return 'an Object type';\n  }\n\n  if (isInterfaceType(type)) {\n    return 'an Interface type';\n  }\n\n  if (isUnionType(type)) {\n    return 'a Union type';\n  }\n\n  if (isEnumType(type)) {\n    return 'an Enum type';\n  } // istanbul ignore else (See: 'https://github.com/graphql/graphql-js/issues/2618')\n\n\n  if (isInputObjectType(type)) {\n    return 'an Input type';\n  } // istanbul ignore next (Not reachable. All possible named types have been considered)\n\n\n  false || invariant(0, 'Unexpected type: ' + inspect(type));\n}\n\nfunction stringifyValue(value, type) {\n  var ast = astFromValue(value, type);\n  ast != null || invariant(0);\n  var sortedAST = visit(ast, {\n    ObjectValue: function ObjectValue(objectNode) {\n      // Make a copy since sort mutates array\n      var fields = [].concat(objectNode.fields);\n      fields.sort(function (fieldA, fieldB) {\n        return naturalCompare(fieldA.name.value, fieldB.name.value);\n      });\n      return _objectSpread(_objectSpread({}, objectNode), {}, {\n        fields: fields\n      });\n    }\n  });\n  return print(sortedAST);\n}\n\nfunction diff(oldArray, newArray) {\n  var added = [];\n  var removed = [];\n  var persisted = [];\n  var oldMap = keyMap(oldArray, function (_ref11) {\n    var name = _ref11.name;\n    return name;\n  });\n  var newMap = keyMap(newArray, function (_ref12) {\n    var name = _ref12.name;\n    return name;\n  });\n\n  for (var _i44 = 0; _i44 < oldArray.length; _i44++) {\n    var oldItem = oldArray[_i44];\n    var newItem = newMap[oldItem.name];\n\n    if (newItem === undefined) {\n      removed.push(oldItem);\n    } else {\n      persisted.push([oldItem, newItem]);\n    }\n  }\n\n  for (var _i46 = 0; _i46 < newArray.length; _i46++) {\n    var _newItem = newArray[_i46];\n\n    if (oldMap[_newItem.name] === undefined) {\n      added.push(_newItem);\n    }\n  }\n\n  return {\n    added: added,\n    persisted: persisted,\n    removed: removed\n  };\n}\n","import { validate } from \"../validation/validate.mjs\";\nimport { NoDeprecatedCustomRule } from \"../validation/rules/custom/NoDeprecatedCustomRule.mjs\";\n/**\n * A validation rule which reports deprecated usages.\n *\n * Returns a list of GraphQLError instances describing each deprecated use.\n *\n * @deprecated Please use `validate` with `NoDeprecatedCustomRule` instead:\n *\n * ```\n * import { validate, NoDeprecatedCustomRule } from 'graphql'\n *\n * const errors = validate(schema, document, [NoDeprecatedCustomRule])\n * ```\n */\n\nexport function findDeprecatedUsages(schema, ast) {\n  return validate(schema, ast, [NoDeprecatedCustomRule]);\n}\n"],"sourceRoot":""}